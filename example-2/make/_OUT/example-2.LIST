     1                                  ; ================================================================
     2                                  ; 这是运行在裸机上的MBR代码，NASM的16位汇编完成
     3                                  ; 内存加载地址：07c00h 
     4                                  ; 完成功能：
     5                                  ;     加载 1号扇区开始的20个扇区的代码至内存地址，并将运行权利叫个它
     6                                  ; ================================================================
     7                                  %include "COMMON.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     通用功能的
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_common
     8                              <1> %define lib_common
     9                              <1> 
    10                              <1> ; ---------------------------------------
    11                              <1> ; 宏说明：
    12                              <1> ;   初始化段寄存器
    13                              <1> ; 使用方法：
    14                              <1> ;   intseg  DS,ES
    15                              <1> ; ---------------------------------------
    16                              <1> %macro intseg 2
    17                              <1>     push ax
    18                              <1>     mov ax, %1           
    19                              <1>     mov ds, ax   
    20                              <1>     mov ax, %2           
    21                              <1>     mov es, ax
    22                              <1>     pop ax
    23                              <1> %endmacro 
    24                              <1> 
    25                              <1> ; ---------------------------------------
    26                              <1> ; 宏说明：
    27                              <1> ;   将指定的一些列寄存器压栈
    28                              <1> ; 使用方法：
    29                              <1> ;   multipush    ax,bx,cs,ds,.....
    30                              <1> ; ---------------------------------------
    31                              <1> %macro  multipush 1-*.nolist
    32                              <1> %rep  %0                
    33                              <1>     push    %1          
    34                              <1>     %rotate 1          
    35                              <1> %endrep              
    36                              <1> %endmacro 
    37                              <1> 
    38                              <1> ; ---------------------------------------
    39                              <1> ; 宏说明：
    40                              <1> ;   将指定的一些列寄存器出栈
    41                              <1> ; 使用方法：
    42                              <1> ;   multipop    ax,bx,cs,ds,.....
    43                              <1> ; 其它说明：
    44                              <1> ;   寄存器顺序与使用 multipush 的时候需保持一致
    45                              <1> ; ---------------------------------------
    46                              <1> %macro  multipop 1-*.nolist
    47                              <1> %rep %0          
    48                              <1>     %rotate -1               
    49                              <1>     pop     %1          
    50                              <1> %endrep               
    51                              <1> %endmacro 
    52                              <1> 
    53                              <1> ; ---------------------------------------
    54                              <1> ; 宏说明：
    55                              <1> ;   简化调用时候的传参，此宏定义必须 与 callbackpop 搭配使用
    56                              <1> ; 使用方法：
    57                              <1> ;   call    参数1, 参数2，...
    58                              <1> ; ---------------------------------------
    59                              <1> %macro  callpush 1-*;.nolist
    60                              <1> %push   callcontext
    61                              <1> %assign %$localsize %0
    62                              <1> push 0
    63                              <1> %rep %0          
    64                              <1>     %rotate -1
    65                              <1>     push    %1          
    66                              <1> %endrep       
    67                              <1> %endmacro 
    68                              <1> 
    69                              <1> ; ---------------------------------------
    70                              <1> ; 宏说明：
    71                              <1> ;   简化调用时候的传参，此宏定义必须 与 callpush 搭配使用
    72                              <1> ; 使用方法：
    73                              <1> ;   call    返回值
    74                              <1> ; ---------------------------------------
    75                              <1> %macro  callbackpop 1
    76                              <1> mov %1, ax
    77                              <1> %rep %$localsize          
    78                              <1>     pop ax
    79                              <1> %endrep
    80                              <1> mov ax,%1
    81                              <1> pop %1
    82                              <1> %pop
    83                              <1> %endmacro 
    84                              <1> 
    85                              <1> ; ---------------------------------------
    86                              <1> ; 宏说明：
    87                              <1> ;   封装了 callpush 和  callbackpop 的调用，之后再也不用管参数的压栈顺序了
    88                              <1> ; 使用方法：
    89                              <1> ;   call    要调用的函数, 返回值存储地址，{参数1, 参数2, 参数3}
    90                              <1> ; ---------------------------------------
    91                              <1> %macro smallcall 3
    92                              <1> callpush %3
    93                              <1> call %1
    94                              <1> callbackpop %2
    95                              <1> %endmacro
    96                              <1> 
    97                              <1> ; ---------------------------------------
    98                              <1> ; 宏说明：
    99                              <1> ;   将指定的段的段地址保存到指定寄存器中
   100                              <1> ; 使用方法：
   101                              <1> ;    myseg    段寄存器, 段名称
   102                              <1> ; ---------------------------------------
   103                              <1> %macro  myseg 2.nolist         
   104                              <1>     multipush   ax
   105                              <1>     ;
   106                              <1>     mov ax, section.%2.start
   107                              <1>     mov %1,ax
   108                              <1>     ;
   109                              <1>     multipop    ax             
   110                              <1> %endmacro 
   111                              <1> 
   112                              <1> 
   113                              <1> ; ---------------------------------------
   114                              <1> ; 宏说明：
   115                              <1> ;   将指定值复制到指定内存中, 安全函数，不会改变借用的寄存器的值
   116                              <1> ; 使用方法：
   117                              <1> ;    memset    借用的寄存器, 内存地址, 值
   118                              <1> ; ---------------------------------------
   119                              <1> %macro  memset 3.nolist         
   120                              <1>     multipush   %1
   121                              <1>     ;
   122                              <1>     mov %1, %3
   123                              <1>     mov %2,%1
   124                              <1>     ;
   125                              <1>     multipop    %1             
   126                              <1> %endmacro 
   127                              <1> 
   128                              <1> ; ---------------------------------------
   129                              <1> ; 宏说明：
   130                              <1> ;   将指定值复制到指定内存中, 与memset的不同是，不安全函数，会改变借用的寄存器的值
   131                              <1> ; 使用方法：
   132                              <1> ;    memset_byax    借用的寄存器, 内存地址, 值
   133                              <1> ; ---------------------------------------
   134                              <1> %macro  memset_unsafe 3.nolist         
   135                              <1>     ;
   136                              <1>     mov %1, %3
   137                              <1>     mov %2, %1
   138                              <1>     ;          
   139                              <1> %endmacro 
   140                              <1> 
   141                              <1> %endif
     8                                  %include "PRINT.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 这是关于打印信息的相关宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     字符串打赢的宏定义
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_print
     8                              <1> %define lib_print
     9                              <1> 
    10                              <1> %include "COMMON.ASM"
     1                              <2> ; ================================================================
     2                              <2> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <2> ; 完成功能：
     4                              <2> ;     通用功能的
     5                              <2> ; ================================================================
     6                              <2> 
     7                              <2> %ifndef lib_common
     8                              <2> %define lib_common
     9                              <2> 
    10                              <2> ; ---------------------------------------
    11                              <2> ; 宏说明：
    12                              <2> ;   初始化段寄存器
    13                              <2> ; 使用方法：
    14                              <2> ;   intseg  DS,ES
    15                              <2> ; ---------------------------------------
    16                              <2> %macro intseg 2
    17                              <2>     push ax
    18                              <2>     mov ax, %1           
    19                              <2>     mov ds, ax   
    20                              <2>     mov ax, %2           
    21                              <2>     mov es, ax
    22                              <2>     pop ax
    23                              <2> %endmacro 
    24                              <2> 
    25                              <2> ; ---------------------------------------
    26                              <2> ; 宏说明：
    27                              <2> ;   将指定的一些列寄存器压栈
    28                              <2> ; 使用方法：
    29                              <2> ;   multipush    ax,bx,cs,ds,.....
    30                              <2> ; ---------------------------------------
    31                              <2> %macro  multipush 1-*.nolist
    32                              <2> %rep  %0                
    33                              <2>     push    %1          
    34                              <2>     %rotate 1          
    35                              <2> %endrep              
    36                              <2> %endmacro 
    37                              <2> 
    38                              <2> ; ---------------------------------------
    39                              <2> ; 宏说明：
    40                              <2> ;   将指定的一些列寄存器出栈
    41                              <2> ; 使用方法：
    42                              <2> ;   multipop    ax,bx,cs,ds,.....
    43                              <2> ; 其它说明：
    44                              <2> ;   寄存器顺序与使用 multipush 的时候需保持一致
    45                              <2> ; ---------------------------------------
    46                              <2> %macro  multipop 1-*.nolist
    47                              <2> %rep %0          
    48                              <2>     %rotate -1               
    49                              <2>     pop     %1          
    50                              <2> %endrep               
    51                              <2> %endmacro 
    52                              <2> 
    53                              <2> ; ---------------------------------------
    54                              <2> ; 宏说明：
    55                              <2> ;   简化调用时候的传参，此宏定义必须 与 callbackpop 搭配使用
    56                              <2> ; 使用方法：
    57                              <2> ;   call    参数1, 参数2，...
    58                              <2> ; ---------------------------------------
    59                              <2> %macro  callpush 1-*;.nolist
    60                              <2> %push   callcontext
    61                              <2> %assign %$localsize %0
    62                              <2> push 0
    63                              <2> %rep %0          
    64                              <2>     %rotate -1
    65                              <2>     push    %1          
    66                              <2> %endrep       
    67                              <2> %endmacro 
    68                              <2> 
    69                              <2> ; ---------------------------------------
    70                              <2> ; 宏说明：
    71                              <2> ;   简化调用时候的传参，此宏定义必须 与 callpush 搭配使用
    72                              <2> ; 使用方法：
    73                              <2> ;   call    返回值
    74                              <2> ; ---------------------------------------
    75                              <2> %macro  callbackpop 1
    76                              <2> mov %1, ax
    77                              <2> %rep %$localsize          
    78                              <2>     pop ax
    79                              <2> %endrep
    80                              <2> mov ax,%1
    81                              <2> pop %1
    82                              <2> %pop
    83                              <2> %endmacro 
    84                              <2> 
    85                              <2> ; ---------------------------------------
    86                              <2> ; 宏说明：
    87                              <2> ;   封装了 callpush 和  callbackpop 的调用，之后再也不用管参数的压栈顺序了
    88                              <2> ; 使用方法：
    89                              <2> ;   call    要调用的函数, 返回值存储地址，{参数1, 参数2, 参数3}
    90                              <2> ; ---------------------------------------
    91                              <2> %macro smallcall 3
    92                              <2> callpush %3
    93                              <2> call %1
    94                              <2> callbackpop %2
    95                              <2> %endmacro
    96                              <2> 
    97                              <2> ; ---------------------------------------
    98                              <2> ; 宏说明：
    99                              <2> ;   将指定的段的段地址保存到指定寄存器中
   100                              <2> ; 使用方法：
   101                              <2> ;    myseg    段寄存器, 段名称
   102                              <2> ; ---------------------------------------
   103                              <2> %macro  myseg 2.nolist         
   104                              <2>     multipush   ax
   105                              <2>     ;
   106                              <2>     mov ax, section.%2.start
   107                              <2>     mov %1,ax
   108                              <2>     ;
   109                              <2>     multipop    ax             
   110                              <2> %endmacro 
   111                              <2> 
   112                              <2> 
   113                              <2> ; ---------------------------------------
   114                              <2> ; 宏说明：
   115                              <2> ;   将指定值复制到指定内存中, 安全函数，不会改变借用的寄存器的值
   116                              <2> ; 使用方法：
   117                              <2> ;    memset    借用的寄存器, 内存地址, 值
   118                              <2> ; ---------------------------------------
   119                              <2> %macro  memset 3.nolist         
   120                              <2>     multipush   %1
   121                              <2>     ;
   122                              <2>     mov %1, %3
   123                              <2>     mov %2,%1
   124                              <2>     ;
   125                              <2>     multipop    %1             
   126                              <2> %endmacro 
   127                              <2> 
   128                              <2> ; ---------------------------------------
   129                              <2> ; 宏说明：
   130                              <2> ;   将指定值复制到指定内存中, 与memset的不同是，不安全函数，会改变借用的寄存器的值
   131                              <2> ; 使用方法：
   132                              <2> ;    memset_byax    借用的寄存器, 内存地址, 值
   133                              <2> ; ---------------------------------------
   134                              <2> %macro  memset_unsafe 3.nolist         
   135                              <2>     ;
   136                              <2>     mov %1, %3
   137                              <2>     mov %2, %1
   138                              <2>     ;          
   139                              <2> %endmacro 
   140                              <2> 
   141                              <2> %endif
    11                              <1> 
    12                              <1> ; ================================================================
    13                              <1> ; 调用宏定义
    14                              <1> ; 所有函数都使用对应的宏定义来调用
    15                              <1> ; ================================================================
    16                              <1> %macro printf_init 0
    17                              <1>     call proc_printf_init
    18                              <1> %endmacro
    19                              <1> 
    20                              <1> 
    21                              <1> ; ---------------------------------------
    22                              <1> ; 宏说明：
    23                              <1> ;   清楚屏幕内容
    24                              <1> ; 使用方法：
    25                              <1> ;   printfreturn    
    26                              <1> ; ---------------------------------------
    27                              <1> %macro printfclear 0
    28                              <1>     call proc_printf_clear
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> ; ---------------------------------------
    32                              <1> ; 宏说明：
    33                              <1> ;   回到行的开头
    34                              <1> ; 使用方法：
    35                              <1> ;   printfreturn    
    36                              <1> ; ---------------------------------------
    37                              <1> %macro printfreturn 0
    38                              <1>     call proc_printfreturn
    39                              <1> %endmacro
    40                              <1> 
    41                              <1> ; ---------------------------------------
    42                              <1> ; 宏说明：
    43                              <1> ;   换到下一行
    44                              <1> ; 使用方法：
    45                              <1> ;   printfaddlen    长度
    46                              <1> ; ---------------------------------------
    47                              <1> %macro printfenter 0
    48                              <1>     call proc_printfenter
    49                              <1> %endmacro
    50                              <1> 
    51                              <1> 
    52                              <1> ; ---------------------------------------
    53                              <1> ; 宏说明：
    54                              <1> ;   回车换行
    55                              <1> ; 使用方法：
    56                              <1> ;   printfendl    长度
    57                              <1> ; ---------------------------------------
    58                              <1> %macro printfendl 0
    59                              <1>     call proc_printfendl
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> 
    63                              <1> ; ---------------------------------------
    64                              <1> ; 宏说明：
    65                              <1> ;   增加每一行的打印起始点坐标
    66                              <1> ; 使用方法：
    67                              <1> ;   printfaddlen    长度
    68                              <1> ; ---------------------------------------
    69                              <1> %macro printfaddlen 1
    70                              <1>     multipush ax
    71                              <1>     push %1
    72                              <1>     call proc_printfaddlen
    73                              <1>     pop ax
    74                              <1>     multipop ax
    75                              <1> %endmacro
    76                              <1> 
    77                              <1> ; ---------------------------------------
    78                              <1> ; 宏说明：
    79                              <1> ;   打印一段字符串
    80                              <1> ; 使用方法：
    81                              <1> ;   printf    字符串起始地址,字符串的长度
    82                              <1> ; ---------------------------------------
    83                              <1> %macro printf 2
    84                              <1>     multipush ax
    85                              <1>     push %2
    86                              <1>     push %1
    87                              <1>     call proc_printf
    88                              <1>     pop ax
    89                              <1>     pop ax
    90                              <1>     multipop ax
    91                              <1> %endmacro
    92                              <1> 
    93                              <1> ; ---------------------------------------
    94                              <1> ; 宏说明：
    95                              <1> ;   打印一段字符串
    96                              <1> ; 使用方法：
    97                              <1> ;   printf    字符串起始地址,字符串的长度, 颜色
    98                              <1> ; 其他说明：
    99                              <1> ;       颜色
   100                              <1> ;        0	黑色		8	灰色	
   101                              <1> ;        1	蓝色		9	亮蓝色	 
   102                              <1> ;        2	绿色		A	亮绿色	
   103                              <1> ;        3	青色		B	亮青色	
   104                              <1> ;        4	红色		C	亮红色	
   105                              <1> ;        5	紫红色		D	亮紫红色	
   106                              <1> ;        6	棕色		E	黄色	
   107                              <1> ;        7	银色	 	F	白色	
   108                              <1> ; ---------------------------------------
   109                              <1> %macro printf_color 3
   110                              <1>     multipush ax
   111                              <1>     push %3
   112                              <1>     push %2
   113                              <1>     push %1
   114                              <1>     call proc_printf_color
   115                              <1>     pop ax
   116                              <1>     pop ax
   117                              <1>     pop ax
   118                              <1>     multipop ax
   119                              <1> %endmacro
   120                              <1> 
   121                              <1> 
   122                              <1> ; ================================================================
   123                              <1> ; 调用函数
   124                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
   125                              <1> ; ================================================================
   126                              <1> 
   127                              <1> section .bss
   128 00000000 <res 00000001>      <1>     lib_string_hang resb 1              ; 最多25行
   129 00000001 <res 00000001>      <1>     lib_string_lie  resb 1              ; 一行最多80个字符
   130                              <1> section lib_print_section
   131                              <1> 
   132                              <1> ; ---------------------------------------
   133                              <1> ; 函数说明：
   134                              <1> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   135                              <1> ; 使用方法：
   136                              <1> ;   printfaddlen    长度
   137                              <1> ; ---------------------------------------
   138                              <1> proc_printf_init:
   139 00000000 C8000000            <1>     enter 0, 0
   140 00000004 50                  <1>     multipush   ax
   141 00000005 B80000              <1>     mov ax, 0
   142 00000008 A2[0000]            <1>     mov [lib_string_hang], al
   143 0000000B A2[0100]            <1>     mov [lib_string_lie], al
   144 0000000E 58                  <1>     multipop   ax
   145 0000000F C9                  <1>     leave
   146 00000010 C3                  <1>     ret
   147                              <1> 
   148                              <1> ; ---------------------------------------
   149                              <1> ; 函数说明：
   150                              <1> ;   重新设定光标位置
   151                              <1> ; 使用方法：
   152                              <1> ;   printfaddlen    长度
   153                              <1> ; ---------------------------------------
   154                              <1> proc_printf_pos:
   155 00000011 C8000000            <1>     enter 0, 0
   156 00000015 505352              <1>     multipush ax,bx,dx
   157 00000018 B80000              <1>     mov ax,0
   158 0000001B B402                <1>     mov ah, 02h
   159 0000001D B700                <1>     mov bh,0
   160 0000001F 8A36[0000]          <1>     mov dh, [lib_string_hang]
   161 00000023 8A16[0100]          <1>     mov dl, [lib_string_lie]
   162 00000027 CD10                <1>     int 10h
   163 00000029 5A5B58              <1>     multipop ax,bx,dx
   164 0000002C C9                  <1>     leave
   165 0000002D C3                  <1>     ret
   166                              <1> 
   167                              <1> ; ---------------------------------------
   168                              <1> ; 函数说明：
   169                              <1> ;   回到行的开头
   170                              <1> ; 使用方法：
   171                              <1> ;   printfreturn    
   172                              <1> ; ---------------------------------------
   173                              <1> proc_printfreturn:
   174 0000002E C8000000            <1>     enter 0, 0
   175 00000032 50                  <1>     multipush   ax
   176 00000033 B000                <1>     mov al, 0 
   177 00000035 A2[0100]            <1>     mov [lib_string_lie],  al
   178 00000038 E8D6FF              <1>     call proc_printf_pos
   179 0000003B 58                  <1>     multipop   ax   
   180 0000003C C9                  <1>     leave
   181 0000003D C3                  <1>     ret
   182                              <1> ; ---------------------------------------
   183                              <1> ; 函数说明：
   184                              <1> ;   换到下一行
   185                              <1> ; 使用方法：
   186                              <1> ;   printfaddlen    长度
   187                              <1> ; ---------------------------------------
   188                              <1> proc_printfenter:
   189 0000003E C8000000            <1>     enter 0, 0
   190 00000042 50                  <1>     multipush   ax
   191 00000043 A0[0000]            <1>     mov al, [lib_string_hang] 
   192 00000046 3C18                <1>     cmp al, 24                         ; 如果 lib_string_hang = 24，那么不能再增加了
   193 00000048 7408                <1>     jz  .donothing
   194 0000004A 0401                <1>     add al, 1                          ; 否则 AL+1
   195 0000004C A2[0000]            <1>     mov [lib_string_hang],  al
   196 0000004F E8BFFF              <1>     call proc_printf_pos
   197                              <1> .donothing:
   198 00000052 58                  <1>     multipop   ax   
   199 00000053 C9                  <1>     leave
   200 00000054 C3                  <1>     ret
   201                              <1> 
   202                              <1> ; ---------------------------------------
   203                              <1> ; 函数说明：
   204                              <1> ;   回车换行
   205                              <1> ; 使用方法：
   206                              <1> ;   printfendl    长度
   207                              <1> ; ---------------------------------------
   208                              <1> proc_printfendl:
   209 00000055 C8000000            <1>     enter 0, 0
   210                              <1>     printfenter
   210 00000059 E8E2FF              <2>  call proc_printfenter
   211                              <1>     printfreturn
   211 0000005C E8CFFF              <2>  call proc_printfreturn
   212 0000005F C9                  <1>     leave
   213 00000060 C3                  <1>     ret
   214                              <1> 
   215                              <1> ; ---------------------------------------
   216                              <1> ; 函数说明：
   217                              <1> ;   增加每一行的打印起始点坐标
   218                              <1> ; 使用方法：
   219                              <1> ;   printfaddlen    长度
   220                              <1> ; ---------------------------------------
   221                              <1> proc_printfaddlen:
   222                              <1>     %push disk_io_context         ; 上下文压栈            
   223                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   224                              <1>     %arg length:word ; 定义参数
   225                              <1> 
   226 00000061 C8000000            <1>     enter 0, 0
   227 00000065 50                  <1>     multipush   ax
   228 00000066 B80000              <1>     mov ax, 0
   229 00000069 A0[0100]            <1>     mov al,[lib_string_lie]
   230 0000006C 034604              <1>     add ax, [length]
   231                              <1> .again:
   232 0000006F 83F850              <1>     cmp ax, 80
   233 00000072 7709                <1>     ja .dayu
   234 00000074 7202                <1>     jb .xiaoyu
   235 00000076 EB0D                <1>     jmp .dengyu
   236                              <1> .xiaoyu:   ; 小于就结束了
   237 00000078 A2[0100]            <1>     mov [lib_string_lie], al 
   238 0000007B EB0B                <1>     jmp .end           
   239                              <1> .dayu:     ; 大于，还需要循环
   240 0000007D 83E850              <1>     sub ax, 80
   241                              <1>     printfendl
   241 00000080 E8D2FF              <2>  call proc_printfendl
   242 00000083 EBEA                <1>     jmp .again
   243                              <1> .dengyu:   ; 等于也结束了
   244                              <1>     printfendl
   244 00000085 E8CDFF              <2>  call proc_printfendl
   245                              <1> .end:
   246 00000088 58                  <1>     multipop   ax
   247 00000089 C9                  <1>     leave
   248 0000008A C3                  <1>     ret
   249                              <1> 
   250                              <1>     %pop
   251                              <1> 
   252                              <1> ; ---------------------------------------
   253                              <1> ; 函数说明：
   254                              <1> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   255                              <1> ; 使用方法：
   256                              <1> ;   printfaddlen    长度
   257                              <1> ; ---------------------------------------
   258                              <1> proc_printf_clear:
   259 0000008B C8000000            <1>     enter 0, 0
   260 0000008F 50515253            <1>     multipush   ax,cx,dx,bx
   261                              <1> 
   262 00000093 B406                <1>     mov ah,0x06
   263 00000095 B000                <1>     mov al,0   ;清窗口
   264 00000097 B90000              <1>     mov cx,0   ;左上角的行号
   265 0000009A B619                <1>     mov dh,25  ;右下角的行号
   266 0000009C B250                <1>     mov dl,80  ;右下角的行号
   267 0000009E B70F                <1>     mov bh,0x0f;属性为黑底白字
   268 000000A0 CD10                <1>     int 0x10
   269                              <1> 
   270 000000A2 B000                <1>     mov al, 0 
   271 000000A4 A2[0100]            <1>     mov [lib_string_lie],  al
   272 000000A7 A2[0000]            <1>     mov [lib_string_hang],  al
   273 000000AA E864FF              <1>     call proc_printf_pos
   274                              <1> 
   275 000000AD 5B5A5958            <1>     multipop   ax,cx,dx,bx
   276 000000B1 C9                  <1>     leave
   277 000000B2 C3                  <1>     ret
   278                              <1> 
   279                              <1> ; ---------------------------------------
   280                              <1> ; 函数说明：
   281                              <1> ;   打印一段字符串
   282                              <1> ; 使用方法：
   283                              <1> ;   printf    字符串起始地址,字符串的长度
   284                              <1> ; ---------------------------------------
   285                              <1> proc_printf:
   286                              <1>     %push disk_io_context         ; 上下文压栈            
   287                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   288                              <1>     %arg offset:word, length:word ; 定义参数
   289                              <1> 
   290 000000B3 C8000000            <1>     enter 0, 0
   291 000000B7 5053515255          <1>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   292                              <1> 
   293 000000BC 8B4E06              <1>     mov cx, [length]                ; CX = 串长度
   294 000000BF BB0F00              <1>     mov bx, 000fh                   ; 页号为0(BH = 0) 黑底白字(BL = 0Fh,高亮)
   295 000000C2 8A16[0100]          <1>     mov dl, [lib_string_lie]        ; 列
   296 000000C6 8A36[0000]          <1>     mov dh, [lib_string_hang]       ; 行
   297                              <1> 
   298 000000CA 8B4604              <1>     mov ax, [offset]
   299 000000CD 55                  <1>     push bp
   300 000000CE 89C5                <1>     mov bp, ax                      ; ES:BP = 串地址
   301 000000D0 B80113              <1>     mov ax, 01301h                  ; AH = 13, AL = 01h
   302 000000D3 CD10                <1>     int 10h ; 10h 号中断
   303 000000D5 5D                  <1>     pop bp
   304                              <1> 
   305 000000D6 8B4E06              <1>     mov cx, [length]
   306                              <1>     printfaddlen    cx
   306 000000D9 50                  <2>  multipush ax
   306 000000DA 51                  <2>  push %1
   306 000000DB E883FF              <2>  call proc_printfaddlen
   306 000000DE 58                  <2>  pop ax
   306 000000DF 58                  <2>  multipop ax
   307                              <1> 
   308 000000E0 5D5A595B58          <1>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   309 000000E5 C9                  <1>     leave
   310 000000E6 C3                  <1>     ret
   311                              <1> 
   312                              <1>     %pop
   313                              <1> 
   314                              <1> ; ---------------------------------------
   315                              <1> ; 函数说明：
   316                              <1> ;   打印一段字符串
   317                              <1> ; 使用方法：
   318                              <1> ;   printf    字符串起始地址,字符串的长度, 颜色
   319                              <1> ; 其他说明：
   320                              <1> ;       颜色
   321                              <1> ;        0	黑色		8	灰色	
   322                              <1> ;        1	蓝色		9	亮蓝色	 
   323                              <1> ;        2	绿色		A	亮绿色	
   324                              <1> ;        3	青色		B	亮青色	
   325                              <1> ;        4	红色		C	亮红色	
   326                              <1> ;        5	紫红色		D	亮紫红色	
   327                              <1> ;        6	棕色		E	黄色	
   328                              <1> ;        7	银色	 	F	白色	
   329                              <1> ; ---------------------------------------
   330                              <1> proc_printf_color:
   331                              <1>     %push disk_io_context         ; 上下文压栈            
   332                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   333                              <1>     %arg offset:word, length:word, color:word       ; 定义参数
   334                              <1> 
   335 000000E7 C8000000            <1>     enter 0, 0
   336 000000EB 5053515255          <1>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   337 000000F0 8B4E06              <1>     mov cx, [length]                ; CX = 串长度
   338                              <1> 
   339 000000F3 8B5E08              <1>     mov bx, [color]                 ; 前景色和背景色
   340 000000F6 B700                <1>     mov bh, 0h                      ; 页号为0(BH = 0) 
   341 000000F8 8A16[0100]          <1>     mov dl, [lib_string_lie]        ; 列
   342 000000FC 8A36[0000]          <1>     mov dh, [lib_string_hang]       ; 行
   343                              <1> 
   344 00000100 8B4604              <1>     mov ax, [offset]
   345 00000103 55                  <1>     push bp
   346 00000104 89C5                <1>     mov bp, ax                      ; ES:BP = 串地址
   347 00000106 B80113              <1>     mov ax, 01301h                  ; AH = 13, AL = 01h
   348 00000109 CD10                <1>     int 10h ; 10h 号中断
   349 0000010B 5D                  <1>     pop bp
   350                              <1>     
   351 0000010C 8B4E06              <1>     mov cx, [length]
   352                              <1>     printfaddlen    cx
   352 0000010F 50                  <2>  multipush ax
   352 00000110 51                  <2>  push %1
   352 00000111 E84DFF              <2>  call proc_printfaddlen
   352 00000114 58                  <2>  pop ax
   352 00000115 58                  <2>  multipop ax
   353                              <1> 
   354 00000116 5D5A595B58          <1>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   355 0000011B C9                  <1>     leave
   356 0000011C C3                  <1>     ret
   357                              <1> 
   358                              <1>     %pop
   359                              <1> %endif
     9                                  %include "STRING.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     通用功能的
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_string
     8                              <1> %define lib_string
     9                              <1> 
    10                              <1> ; ================================================================
    11                              <1> ; 调用宏定义
    12                              <1> ; 所有函数都使用对应的宏定义来调用
    13                              <1> ; ================================================================
    14                              <1> 
    15                              <1> ; ---------------------------------------
    16                              <1> ; 宏说明：
    17                              <1> ;   简化字符串的定义，一般用在 data 段中
    18                              <1> ; 使用方法：
    19                              <1> ;    defstring    字符串名称, 字符串长度的名称，字符串内容
    20                              <1> ; ---------------------------------------
    21                              <1> %macro  defstring 3.nolist       
    22                              <1>     ;
    23                              <1>     %1: db %3         ; 定义文字的内存
    24                              <1>     %2 equ $-%1       ; 计算文字长度
    25                              <1>     ;             
    26                              <1> %endmacro 
    27                              <1> 
    28                              <1> ; ---------------------------------------
    29                              <1> ; 宏说明：
    30                              <1> ;   字符串比较
    31                              <1> ; 使用方法：
    32                              <1> ;    strstr    字符串名称1, 字符串1长度, 字符串名称2， 字符串2长度, 返回值存储寄存器
    33                              <1> ;    返回值     0 表示一致   其他表示不一致
    34                              <1> ; ---------------------------------------
    35                              <1> %macro  strcmp  5 ;.nolist       
    36                              <1>     smallcall proc_strcmp, %5, {%1,%2,%3,%4}
    37                              <1> %endmacro 
    38                              <1> 
    39                              <1> ; ================================================================
    40                              <1> ; 调用函数
    41                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
    42                              <1> ; ================================================================
    43                              <1> section lib_string_section
    44                              <1> ; ---------------------------------------
    45                              <1> ; 函数说明：
    46                              <1> ;   字符串比较
    47                              <1> ; 使用方法：
    48                              <1> ;    strstr    字符串名称1, 字符串1长度, 字符串名称2， 字符串2长度, 返回值存储寄存器
    49                              <1> ;    返回值     0 表示一致   其他表示不一致
    50                              <1> ; ---------------------------------------
    51                              <1> proc_strcmp:
    52                              <1>     ; 函数的一些相关定义
    53                              <1>     %push disk_io_context         ; 上下文压栈            
    54                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
    55                              <1>     %assign %$localsize 16 
    56                              <1>     %arg src:word, srclen:word, des:word, deslen:word, rv:word    ; 定义参数
    57                              <1> 
    58                              <1>     ; 函数体正式开始
    59 00000000 C8100000            <1>     enter       16,    0   ; 确保堆栈平衡，以及开辟空间   
    60 00000004 5051531E56          <1>     multipush   ax,cx,bx,ds,si            ; 保存原始寄存器值 
    61                              <1> 
    62                              <1>     ; 先比较字符串长度
    63 00000009 8B4606              <1>     mov ax, [srclen]
    64 0000000C 2B460A              <1>     sub ax, [deslen]
    65 0000000F 7514                <1>     jnz  .noequal
    66                              <1> 
    67                              <1>     ; 长度相等开始比较字符串
    68                              <1> .lenequal:
    69                              <1> 
    70                              <1> 
    71 00000011 8B7604              <1>     mov si, [src]
    72 00000014 8B7E08              <1>     mov di, [des]
    73 00000017 8B4E06              <1>     mov cx, [srclen]
    74                              <1> 
    75 0000001A F3A6                <1>     repz cmpsb
    76                              <1>     ; 标志寄存器不等于0 表示两个字符不相等
    77 0000001C 7507                <1>     jnz .noequal
    78                              <1> 
    79                              <1>     ; 判断了标志寄存器在判断cx 是不是0
    80 0000001E 83E900              <1>     sub cx, 0
    81 00000021 7502                <1>     jnz .noequal
    82                              <1> 
    83                              <1>     ; 到此基本认为是相等了
    84 00000023 EB08                <1>     jmp .equal
    85                              <1> 
    86                              <1>     ; 不相等
    87                              <1> .noequal:
    88 00000025 B80100              <1>     mov ax, 1
    89 00000028 89460C              <1>     mov [rv], ax
    90 0000002B EB08                <1>     jmp .end
    91                              <1> 
    92                              <1>     ; 不等
    93                              <1> .equal:
    94 0000002D B80000              <1>      mov ax, 0
    95 00000030 89460C              <1>     mov [rv], ax
    96 00000033 EB00                <1>     jmp .end
    97                              <1> 
    98                              <1> .end:
    99 00000035 5E1F5B5958          <1>     multipop   ax,cx,bx,ds,si               ; 恢复原始寄存器值
   100 0000003A C9                  <1>     leave                                   ; 恢复堆栈
   101                              <1> 
   102 0000003B C3                  <1>     ret
   103                              <1>     %pop                        ; 上下文出栈
   104                              <1> %endif
    10                                  %include "THREAD.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 线程相关操作,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     SLEEP
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_thread
     8                              <1> %define lib_thread
     9                              <1> 
    10                              <1> ; ================================================================
    11                              <1> ; 调用宏定义
    12                              <1> ; 所有函数都使用对应的宏定义来调用
    13                              <1> ; ================================================================
    14                              <1> 
    15                              <1> ; ---------------------------------------
    16                              <1> ; 宏说明：
    17                              <1> ;   线程sleep函数, 有个缺陷, 开机正好24小时的时候如果在sleep会出问题
    18                              <1> ; 使用方法：
    19                              <1> ;    sleep 秒数, 返回值
    20                              <1> ; ---------------------------------------
    21                              <1> %macro  sleep  2.nolist       
    22                              <1>     smallcall proc_sleep, %2, {%1}
    23                              <1> %endmacro 
    24                              <1> 
    25                              <1> ; ================================================================
    26                              <1> ; 调用函数
    27                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
    28                              <1> ; ================================================================
    29                              <1> section lib_thread_section
    30                              <1> ; ---------------------------------------
    31                              <1> ; 函数说明：
    32                              <1> ;   内存拷贝
    33                              <1> ; 使用方法：
    34                              <1> ;    使用宏定义 memcpy
    35                              <1> ; ---------------------------------------
    36                              <1> proc_sleep:
    37                              <1>     ; 函数的一些相关定义
    38                              <1>     %push disk_io_context         ; 上下文压栈            
    39                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
    40                              <1>     %arg time:word, rv:word    ; 定义参数
    41                              <1> 
    42                              <1>     ; 函数体正式开始
    43 00000000 C8000000            <1>     enter       0,    0   ; 确保堆栈平衡，以及开辟空间   
    44 00000004 5051531E            <1>     multipush   ax,cx,bx,ds            ; 保存原始寄存器值 
    45                              <1> 
    46 00000008 8B4604              <1>     mov ax, [time]
    47 0000000B B312                <1>     mov bl, 18
    48 0000000D F6E3                <1>     mul bl
    49 0000000F 894604              <1>     mov [time], ax
    50                              <1> .again:
    51                              <1>     ; 初始化
    52 00000012 B80000              <1>     mov ax, 0
    53 00000015 8ED8                <1>     mov ds, ax
    54 00000017 A16C04              <1>     mov ax, [046ch]
    55                              <1>     ; 真sleep 等待中断触发
    56 0000001A F4                  <1>     hlt
    57                              <1>     ; 之后比较事件
    58 0000001B 8B1E6C04            <1>     mov bx, [046ch]
    59 0000001F 39C3                <1>     cmp bx,ax
    60                              <1>     ; 相等说明时间没过去，继续等待
    61 00000021 74EF                <1>     je .again
    62                              <1> 
    63 00000023 7709                <1>     ja .bthena  ;说明重计数了
    64 00000025 B9FFFF              <1>         mov cx, 0xffff
    65 00000028 29C1                <1>         sub cx, ax
    66 0000002A 01CB                <1>         add bx, cx
    67 0000002C EB02                <1>         jmp .count
    68                              <1> .bthena:
    69 0000002E 29C3                <1>     sub bx,ax
    70                              <1> .count:
    71 00000030 8B4606              <1>     mov ax, [rv]
    72 00000033 01C3                <1>     add bx, ax  ;累计过去的时间
    73 00000035 895E06              <1>     mov [rv], bx
    74 00000038 8B4604              <1>     mov ax, [time]
    75                              <1> 
    76 0000003B 39D8                <1>     cmp ax, bx
    77                              <1>     ; 还没到时间
    78 0000003D 77D3                <1>     ja .again
    79 0000003F EB00                <1>     jmp .wakeup
    80                              <1> 
    81                              <1> .wakeup:
    82 00000041 8B4606              <1>     mov ax, [rv]
    83 00000044 B312                <1>     mov bl, 18
    84 00000046 F6F3                <1>     div bl
    85 00000048 80FC09              <1>     cmp ah, 9
    86 0000004B 7202                <1>     jb .noadd
    87 0000004D 0401                <1>     add al, 1
    88                              <1> .noadd:
    89 0000004F B400                <1>     mov ah,0
    90 00000051 894606              <1>     mov [rv], ax
    91                              <1> 
    92 00000054 1F5B5958            <1>     multipop   ax,cx,bx,ds               ; 恢复原始寄存器值
    93 00000058 C9                  <1>     leave                                ; 恢复堆栈
    94                              <1> 
    95 00000059 C3                  <1>     ret
    96                              <1>     %pop                        ; 上下文出栈
    97                              <1> %endif
    11                                  %include "KEYBOARD.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 键盘相关功能的宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     完成接收键盘输入的宏定义
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_keyboard
     8                              <1> %define lib_keyboard
     9                              <1> %include "PRINT.ASM"
     1                              <2> ; ================================================================
     2                              <2> ; 这是关于打印信息的相关宏定义,使用NASM的16位汇编完成
     3                              <2> ; 完成功能：
     4                              <2> ;     字符串打赢的宏定义
     5                              <2> ; ================================================================
     6                              <2> 
     7                              <2> %ifndef lib_print
     8                              <2> %define lib_print
     9                              <2> 
    10                              <2> %include "COMMON.ASM"
    11                              <2> 
    12                              <2> ; ================================================================
    13                              <2> ; 调用宏定义
    14                              <2> ; 所有函数都使用对应的宏定义来调用
    15                              <2> ; ================================================================
    16                              <2> %macro printf_init 0
    17                              <2>     call proc_printf_init
    18                              <2> %endmacro
    19                              <2> 
    20                              <2> 
    21                              <2> ; ---------------------------------------
    22                              <2> ; 宏说明：
    23                              <2> ;   清楚屏幕内容
    24                              <2> ; 使用方法：
    25                              <2> ;   printfreturn    
    26                              <2> ; ---------------------------------------
    27                              <2> %macro printfclear 0
    28                              <2>     call proc_printf_clear
    29                              <2> %endmacro
    30                              <2> 
    31                              <2> ; ---------------------------------------
    32                              <2> ; 宏说明：
    33                              <2> ;   回到行的开头
    34                              <2> ; 使用方法：
    35                              <2> ;   printfreturn    
    36                              <2> ; ---------------------------------------
    37                              <2> %macro printfreturn 0
    38                              <2>     call proc_printfreturn
    39                              <2> %endmacro
    40                              <2> 
    41                              <2> ; ---------------------------------------
    42                              <2> ; 宏说明：
    43                              <2> ;   换到下一行
    44                              <2> ; 使用方法：
    45                              <2> ;   printfaddlen    长度
    46                              <2> ; ---------------------------------------
    47                              <2> %macro printfenter 0
    48                              <2>     call proc_printfenter
    49                              <2> %endmacro
    50                              <2> 
    51                              <2> 
    52                              <2> ; ---------------------------------------
    53                              <2> ; 宏说明：
    54                              <2> ;   回车换行
    55                              <2> ; 使用方法：
    56                              <2> ;   printfendl    长度
    57                              <2> ; ---------------------------------------
    58                              <2> %macro printfendl 0
    59                              <2>     call proc_printfendl
    60                              <2> %endmacro
    61                              <2> 
    62                              <2> 
    63                              <2> ; ---------------------------------------
    64                              <2> ; 宏说明：
    65                              <2> ;   增加每一行的打印起始点坐标
    66                              <2> ; 使用方法：
    67                              <2> ;   printfaddlen    长度
    68                              <2> ; ---------------------------------------
    69                              <2> %macro printfaddlen 1
    70                              <2>     multipush ax
    71                              <2>     push %1
    72                              <2>     call proc_printfaddlen
    73                              <2>     pop ax
    74                              <2>     multipop ax
    75                              <2> %endmacro
    76                              <2> 
    77                              <2> ; ---------------------------------------
    78                              <2> ; 宏说明：
    79                              <2> ;   打印一段字符串
    80                              <2> ; 使用方法：
    81                              <2> ;   printf    字符串起始地址,字符串的长度
    82                              <2> ; ---------------------------------------
    83                              <2> %macro printf 2
    84                              <2>     multipush ax
    85                              <2>     push %2
    86                              <2>     push %1
    87                              <2>     call proc_printf
    88                              <2>     pop ax
    89                              <2>     pop ax
    90                              <2>     multipop ax
    91                              <2> %endmacro
    92                              <2> 
    93                              <2> ; ---------------------------------------
    94                              <2> ; 宏说明：
    95                              <2> ;   打印一段字符串
    96                              <2> ; 使用方法：
    97                              <2> ;   printf    字符串起始地址,字符串的长度, 颜色
    98                              <2> ; 其他说明：
    99                              <2> ;       颜色
   100                              <2> ;        0	黑色		8	灰色	
   101                              <2> ;        1	蓝色		9	亮蓝色	 
   102                              <2> ;        2	绿色		A	亮绿色	
   103                              <2> ;        3	青色		B	亮青色	
   104                              <2> ;        4	红色		C	亮红色	
   105                              <2> ;        5	紫红色		D	亮紫红色	
   106                              <2> ;        6	棕色		E	黄色	
   107                              <2> ;        7	银色	 	F	白色	
   108                              <2> ; ---------------------------------------
   109                              <2> %macro printf_color 3
   110                              <2>     multipush ax
   111                              <2>     push %3
   112                              <2>     push %2
   113                              <2>     push %1
   114                              <2>     call proc_printf_color
   115                              <2>     pop ax
   116                              <2>     pop ax
   117                              <2>     pop ax
   118                              <2>     multipop ax
   119                              <2> %endmacro
   120                              <2> 
   121                              <2> 
   122                              <2> ; ================================================================
   123                              <2> ; 调用函数
   124                              <2> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
   125                              <2> ; ================================================================
   126                              <2> 
   127                              <2> section .bss
   128                              <2>     lib_string_hang resb 1              ; 最多25行
   129                              <2>     lib_string_lie  resb 1              ; 一行最多80个字符
   130                              <2> section lib_print_section
   131                              <2> 
   132                              <2> ; ---------------------------------------
   133                              <2> ; 函数说明：
   134                              <2> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   135                              <2> ; 使用方法：
   136                              <2> ;   printfaddlen    长度
   137                              <2> ; ---------------------------------------
   138                              <2> proc_printf_init:
   139                              <2>     enter 0, 0
   140                              <2>     multipush   ax
   141                              <2>     mov ax, 0
   142                              <2>     mov [lib_string_hang], al
   143                              <2>     mov [lib_string_lie], al
   144                              <2>     multipop   ax
   145                              <2>     leave
   146                              <2>     ret
   147                              <2> 
   148                              <2> ; ---------------------------------------
   149                              <2> ; 函数说明：
   150                              <2> ;   重新设定光标位置
   151                              <2> ; 使用方法：
   152                              <2> ;   printfaddlen    长度
   153                              <2> ; ---------------------------------------
   154                              <2> proc_printf_pos:
   155                              <2>     enter 0, 0
   156                              <2>     multipush ax,bx,dx
   157                              <2>     mov ax,0
   158                              <2>     mov ah, 02h
   159                              <2>     mov bh,0
   160                              <2>     mov dh, [lib_string_hang]
   161                              <2>     mov dl, [lib_string_lie]
   162                              <2>     int 10h
   163                              <2>     multipop ax,bx,dx
   164                              <2>     leave
   165                              <2>     ret
   166                              <2> 
   167                              <2> ; ---------------------------------------
   168                              <2> ; 函数说明：
   169                              <2> ;   回到行的开头
   170                              <2> ; 使用方法：
   171                              <2> ;   printfreturn    
   172                              <2> ; ---------------------------------------
   173                              <2> proc_printfreturn:
   174                              <2>     enter 0, 0
   175                              <2>     multipush   ax
   176                              <2>     mov al, 0 
   177                              <2>     mov [lib_string_lie],  al
   178                              <2>     call proc_printf_pos
   179                              <2>     multipop   ax   
   180                              <2>     leave
   181                              <2>     ret
   182                              <2> ; ---------------------------------------
   183                              <2> ; 函数说明：
   184                              <2> ;   换到下一行
   185                              <2> ; 使用方法：
   186                              <2> ;   printfaddlen    长度
   187                              <2> ; ---------------------------------------
   188                              <2> proc_printfenter:
   189                              <2>     enter 0, 0
   190                              <2>     multipush   ax
   191                              <2>     mov al, [lib_string_hang] 
   192                              <2>     cmp al, 24                         ; 如果 lib_string_hang = 24，那么不能再增加了
   193                              <2>     jz  .donothing
   194                              <2>     add al, 1                          ; 否则 AL+1
   195                              <2>     mov [lib_string_hang],  al
   196                              <2>     call proc_printf_pos
   197                              <2> .donothing:
   198                              <2>     multipop   ax   
   199                              <2>     leave
   200                              <2>     ret
   201                              <2> 
   202                              <2> ; ---------------------------------------
   203                              <2> ; 函数说明：
   204                              <2> ;   回车换行
   205                              <2> ; 使用方法：
   206                              <2> ;   printfendl    长度
   207                              <2> ; ---------------------------------------
   208                              <2> proc_printfendl:
   209                              <2>     enter 0, 0
   210                              <2>     printfenter
   211                              <2>     printfreturn
   212                              <2>     leave
   213                              <2>     ret
   214                              <2> 
   215                              <2> ; ---------------------------------------
   216                              <2> ; 函数说明：
   217                              <2> ;   增加每一行的打印起始点坐标
   218                              <2> ; 使用方法：
   219                              <2> ;   printfaddlen    长度
   220                              <2> ; ---------------------------------------
   221                              <2> proc_printfaddlen:
   222                              <2>     %push disk_io_context         ; 上下文压栈            
   223                              <2>     %stacksize large              ; 设置使用bp寄存器来寻址        
   224                              <2>     %arg length:word ; 定义参数
   225                              <2> 
   226                              <2>     enter 0, 0
   227                              <2>     multipush   ax
   228                              <2>     mov ax, 0
   229                              <2>     mov al,[lib_string_lie]
   230                              <2>     add ax, [length]
   231                              <2> .again:
   232                              <2>     cmp ax, 80
   233                              <2>     ja .dayu
   234                              <2>     jb .xiaoyu
   235                              <2>     jmp .dengyu
   236                              <2> .xiaoyu:   ; 小于就结束了
   237                              <2>     mov [lib_string_lie], al 
   238                              <2>     jmp .end           
   239                              <2> .dayu:     ; 大于，还需要循环
   240                              <2>     sub ax, 80
   241                              <2>     printfendl
   242                              <2>     jmp .again
   243                              <2> .dengyu:   ; 等于也结束了
   244                              <2>     printfendl
   245                              <2> .end:
   246                              <2>     multipop   ax
   247                              <2>     leave
   248                              <2>     ret
   249                              <2> 
   250                              <2>     %pop
   251                              <2> 
   252                              <2> ; ---------------------------------------
   253                              <2> ; 函数说明：
   254                              <2> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   255                              <2> ; 使用方法：
   256                              <2> ;   printfaddlen    长度
   257                              <2> ; ---------------------------------------
   258                              <2> proc_printf_clear:
   259                              <2>     enter 0, 0
   260                              <2>     multipush   ax,cx,dx,bx
   261                              <2> 
   262                              <2>     mov ah,0x06
   263                              <2>     mov al,0   ;清窗口
   264                              <2>     mov cx,0   ;左上角的行号
   265                              <2>     mov dh,25  ;右下角的行号
   266                              <2>     mov dl,80  ;右下角的行号
   267                              <2>     mov bh,0x0f;属性为黑底白字
   268                              <2>     int 0x10
   269                              <2> 
   270                              <2>     mov al, 0 
   271                              <2>     mov [lib_string_lie],  al
   272                              <2>     mov [lib_string_hang],  al
   273                              <2>     call proc_printf_pos
   274                              <2> 
   275                              <2>     multipop   ax,cx,dx,bx
   276                              <2>     leave
   277                              <2>     ret
   278                              <2> 
   279                              <2> ; ---------------------------------------
   280                              <2> ; 函数说明：
   281                              <2> ;   打印一段字符串
   282                              <2> ; 使用方法：
   283                              <2> ;   printf    字符串起始地址,字符串的长度
   284                              <2> ; ---------------------------------------
   285                              <2> proc_printf:
   286                              <2>     %push disk_io_context         ; 上下文压栈            
   287                              <2>     %stacksize large              ; 设置使用bp寄存器来寻址        
   288                              <2>     %arg offset:word, length:word ; 定义参数
   289                              <2> 
   290                              <2>     enter 0, 0
   291                              <2>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   292                              <2> 
   293                              <2>     mov cx, [length]                ; CX = 串长度
   294                              <2>     mov bx, 000fh                   ; 页号为0(BH = 0) 黑底白字(BL = 0Fh,高亮)
   295                              <2>     mov dl, [lib_string_lie]        ; 列
   296                              <2>     mov dh, [lib_string_hang]       ; 行
   297                              <2> 
   298                              <2>     mov ax, [offset]
   299                              <2>     push bp
   300                              <2>     mov bp, ax                      ; ES:BP = 串地址
   301                              <2>     mov ax, 01301h                  ; AH = 13, AL = 01h
   302                              <2>     int 10h ; 10h 号中断
   303                              <2>     pop bp
   304                              <2> 
   305                              <2>     mov cx, [length]
   306                              <2>     printfaddlen    cx
   307                              <2> 
   308                              <2>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   309                              <2>     leave
   310                              <2>     ret
   311                              <2> 
   312                              <2>     %pop
   313                              <2> 
   314                              <2> ; ---------------------------------------
   315                              <2> ; 函数说明：
   316                              <2> ;   打印一段字符串
   317                              <2> ; 使用方法：
   318                              <2> ;   printf    字符串起始地址,字符串的长度, 颜色
   319                              <2> ; 其他说明：
   320                              <2> ;       颜色
   321                              <2> ;        0	黑色		8	灰色	
   322                              <2> ;        1	蓝色		9	亮蓝色	 
   323                              <2> ;        2	绿色		A	亮绿色	
   324                              <2> ;        3	青色		B	亮青色	
   325                              <2> ;        4	红色		C	亮红色	
   326                              <2> ;        5	紫红色		D	亮紫红色	
   327                              <2> ;        6	棕色		E	黄色	
   328                              <2> ;        7	银色	 	F	白色	
   329                              <2> ; ---------------------------------------
   330                              <2> proc_printf_color:
   331                              <2>     %push disk_io_context         ; 上下文压栈            
   332                              <2>     %stacksize large              ; 设置使用bp寄存器来寻址        
   333                              <2>     %arg offset:word, length:word, color:word       ; 定义参数
   334                              <2> 
   335                              <2>     enter 0, 0
   336                              <2>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   337                              <2>     mov cx, [length]                ; CX = 串长度
   338                              <2> 
   339                              <2>     mov bx, [color]                 ; 前景色和背景色
   340                              <2>     mov bh, 0h                      ; 页号为0(BH = 0) 
   341                              <2>     mov dl, [lib_string_lie]        ; 列
   342                              <2>     mov dh, [lib_string_hang]       ; 行
   343                              <2> 
   344                              <2>     mov ax, [offset]
   345                              <2>     push bp
   346                              <2>     mov bp, ax                      ; ES:BP = 串地址
   347                              <2>     mov ax, 01301h                  ; AH = 13, AL = 01h
   348                              <2>     int 10h ; 10h 号中断
   349                              <2>     pop bp
   350                              <2>     
   351                              <2>     mov cx, [length]
   352                              <2>     printfaddlen    cx
   353                              <2> 
   354                              <2>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   355                              <2>     leave
   356                              <2>     ret
   357                              <2> 
   358                              <2>     %pop
   359                              <2> %endif
    10                              <1> %include "COMMON.ASM"
     1                              <2> ; ================================================================
     2                              <2> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <2> ; 完成功能：
     4                              <2> ;     通用功能的
     5                              <2> ; ================================================================
     6                              <2> 
     7                              <2> %ifndef lib_common
     8                              <2> %define lib_common
     9                              <2> 
    10                              <2> ; ---------------------------------------
    11                              <2> ; 宏说明：
    12                              <2> ;   初始化段寄存器
    13                              <2> ; 使用方法：
    14                              <2> ;   intseg  DS,ES
    15                              <2> ; ---------------------------------------
    16                              <2> %macro intseg 2
    17                              <2>     push ax
    18                              <2>     mov ax, %1           
    19                              <2>     mov ds, ax   
    20                              <2>     mov ax, %2           
    21                              <2>     mov es, ax
    22                              <2>     pop ax
    23                              <2> %endmacro 
    24                              <2> 
    25                              <2> ; ---------------------------------------
    26                              <2> ; 宏说明：
    27                              <2> ;   将指定的一些列寄存器压栈
    28                              <2> ; 使用方法：
    29                              <2> ;   multipush    ax,bx,cs,ds,.....
    30                              <2> ; ---------------------------------------
    31                              <2> %macro  multipush 1-*.nolist
    32                              <2> %rep  %0                
    33                              <2>     push    %1          
    34                              <2>     %rotate 1          
    35                              <2> %endrep              
    36                              <2> %endmacro 
    37                              <2> 
    38                              <2> ; ---------------------------------------
    39                              <2> ; 宏说明：
    40                              <2> ;   将指定的一些列寄存器出栈
    41                              <2> ; 使用方法：
    42                              <2> ;   multipop    ax,bx,cs,ds,.....
    43                              <2> ; 其它说明：
    44                              <2> ;   寄存器顺序与使用 multipush 的时候需保持一致
    45                              <2> ; ---------------------------------------
    46                              <2> %macro  multipop 1-*.nolist
    47                              <2> %rep %0          
    48                              <2>     %rotate -1               
    49                              <2>     pop     %1          
    50                              <2> %endrep               
    51                              <2> %endmacro 
    52                              <2> 
    53                              <2> ; ---------------------------------------
    54                              <2> ; 宏说明：
    55                              <2> ;   简化调用时候的传参，此宏定义必须 与 callbackpop 搭配使用
    56                              <2> ; 使用方法：
    57                              <2> ;   call    参数1, 参数2，...
    58                              <2> ; ---------------------------------------
    59                              <2> %macro  callpush 1-*;.nolist
    60                              <2> %push   callcontext
    61                              <2> %assign %$localsize %0
    62                              <2> push 0
    63                              <2> %rep %0          
    64                              <2>     %rotate -1
    65                              <2>     push    %1          
    66                              <2> %endrep       
    67                              <2> %endmacro 
    68                              <2> 
    69                              <2> ; ---------------------------------------
    70                              <2> ; 宏说明：
    71                              <2> ;   简化调用时候的传参，此宏定义必须 与 callpush 搭配使用
    72                              <2> ; 使用方法：
    73                              <2> ;   call    返回值
    74                              <2> ; ---------------------------------------
    75                              <2> %macro  callbackpop 1
    76                              <2> mov %1, ax
    77                              <2> %rep %$localsize          
    78                              <2>     pop ax
    79                              <2> %endrep
    80                              <2> mov ax,%1
    81                              <2> pop %1
    82                              <2> %pop
    83                              <2> %endmacro 
    84                              <2> 
    85                              <2> ; ---------------------------------------
    86                              <2> ; 宏说明：
    87                              <2> ;   封装了 callpush 和  callbackpop 的调用，之后再也不用管参数的压栈顺序了
    88                              <2> ; 使用方法：
    89                              <2> ;   call    要调用的函数, 返回值存储地址，{参数1, 参数2, 参数3}
    90                              <2> ; ---------------------------------------
    91                              <2> %macro smallcall 3
    92                              <2> callpush %3
    93                              <2> call %1
    94                              <2> callbackpop %2
    95                              <2> %endmacro
    96                              <2> 
    97                              <2> ; ---------------------------------------
    98                              <2> ; 宏说明：
    99                              <2> ;   将指定的段的段地址保存到指定寄存器中
   100                              <2> ; 使用方法：
   101                              <2> ;    myseg    段寄存器, 段名称
   102                              <2> ; ---------------------------------------
   103                              <2> %macro  myseg 2.nolist         
   104                              <2>     multipush   ax
   105                              <2>     ;
   106                              <2>     mov ax, section.%2.start
   107                              <2>     mov %1,ax
   108                              <2>     ;
   109                              <2>     multipop    ax             
   110                              <2> %endmacro 
   111                              <2> 
   112                              <2> 
   113                              <2> ; ---------------------------------------
   114                              <2> ; 宏说明：
   115                              <2> ;   将指定值复制到指定内存中, 安全函数，不会改变借用的寄存器的值
   116                              <2> ; 使用方法：
   117                              <2> ;    memset    借用的寄存器, 内存地址, 值
   118                              <2> ; ---------------------------------------
   119                              <2> %macro  memset 3.nolist         
   120                              <2>     multipush   %1
   121                              <2>     ;
   122                              <2>     mov %1, %3
   123                              <2>     mov %2,%1
   124                              <2>     ;
   125                              <2>     multipop    %1             
   126                              <2> %endmacro 
   127                              <2> 
   128                              <2> ; ---------------------------------------
   129                              <2> ; 宏说明：
   130                              <2> ;   将指定值复制到指定内存中, 与memset的不同是，不安全函数，会改变借用的寄存器的值
   131                              <2> ; 使用方法：
   132                              <2> ;    memset_byax    借用的寄存器, 内存地址, 值
   133                              <2> ; ---------------------------------------
   134                              <2> %macro  memset_unsafe 3.nolist         
   135                              <2>     ;
   136                              <2>     mov %1, %3
   137                              <2>     mov %2, %1
   138                              <2>     ;          
   139                              <2> %endmacro 
   140                              <2> 
   141                              <2> %endif
    11                              <1> 
    12                              <1> ; ================================================================
    13                              <1> ; 调用宏定义
    14                              <1> ; 所有函数都使用对应的宏定义来调用
    15                              <1> ; ================================================================
    16                              <1> ; ---------------------------------------
    17                              <1> ; 宏说明：
    18                              <1> ;   获取一个字符输入
    19                              <1> ; 使用方法：
    20                              <1> ;    getchar    返回值
    21                              <1> ; ---------------------------------------
    22                              <1> %macro  getchar 1.nolist       
    23                              <1>     ;
    24                              <1>     call proc_keyboard_clear
    25                              <1>     smallcall proc_keyboard_getchar, %1, {0xffff}
    26                              <1>     ;             
    27                              <1> %endmacro 
    28                              <1> 
    29                              <1> ; ---------------------------------------
    30                              <1> ; 宏说明：
    31                              <1> ;   获取一串字符串
    32                              <1> ; 使用方法：
    33                              <1> ;    getno    内存地址, 内存长度, 返回值
    34                              <1> ; ---------------------------------------
    35                              <1> %macro  getline 3.nolist       
    36                              <1>     ;
    37                              <1>     call proc_keyboard_clear
    38                              <1>     smallcall proc_get_line, %3, {0xffff, %1, %2}
    39                              <1>     ;             
    40                              <1> %endmacro 
    41                              <1> 
    42                              <1> ; ---------------------------------------
    43                              <1> ; 宏说明：
    44                              <1> ;   获取一串密码
    45                              <1> ; 使用方法：
    46                              <1> ;    getno    内存地址, 内存长度, 返回值
    47                              <1> ; ---------------------------------------
    48                              <1> %macro  getpassword 3.nolist       
    49                              <1>     ;
    50                              <1>     call proc_keyboard_clear
    51                              <1>     smallcall proc_get_line, %3, {0x0042, %1, %2}
    52                              <1>     ;             
    53                              <1> %endmacro 
    54                              <1> 
    55                              <1> ; ================================================================
    56                              <1> ; 调用函数
    57                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
    58                              <1> ; ================================================================
    59                              <1> section lib_keyboard_section
    60                              <1> ; ---------------------------------------
    61                              <1> ; 函数说明：
    62                              <1> ;   清理键盘缓存
    63                              <1> ; 使用方法：
    64                              <1> ;    call proc_keyboard_clear
    65                              <1> ; ---------------------------------------
    66                              <1> proc_keyboard_clear:
    67                              <1>     ; 函数的一些相关定义
    68                              <1>     %push keyboard_context         ; 上下文压栈            
    69                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
    70                              <1> 
    71                              <1>     ; 函数体正式开始
    72 00000000 C8000000            <1>     enter       0, 0 ; 确保堆栈平衡，以及开辟空间   
    73 00000004 50                  <1>     multipush   ax,         ; 保存原始寄存器值 
    74                              <1> 
    75                              <1> .again:
    76 00000005 B80000              <1>     mov ax,0
    77 00000008 B401                <1>     mov ah, 1
    78 0000000A CD16                <1>     int 16h
    79 0000000C 7406                <1>     jz .end
    80 0000000E B400                <1>     mov ah, 0
    81 00000010 CD16                <1>     int 16h
    82 00000012 EBF1                <1>     jmp .again
    83                              <1> .end:
    84 00000014 58                  <1>     multipop   ax               ; 恢复原始寄存器值
    85 00000015 C9                  <1>     leave                       ; 恢复堆栈
    86                              <1> 
    87 00000016 C3                  <1>     ret
    88                              <1>     %pop                        ; 上下文出栈
    89                              <1> 
    90                              <1> ; ---------------------------------------
    91                              <1> ; 函数说明：
    92                              <1> ;   清理键盘缓存
    93                              <1> ; 使用方法：
    94                              <1> ;    使用 getchar, getline, getpassword, getno宏
    95                              <1> ; ---------------------------------------
    96                              <1> proc_keyboard_getchar:
    97                              <1>     ; 函数的一些相关定义
    98                              <1>     %push keyboard_context         ; 上下文压栈            
    99                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   100                              <1>     %arg mask:word, rv:word    
   101                              <1> 
   102                              <1>     ; 函数体正式开始
   103 00000017 C8000000            <1>     enter       0, 0            ; 确保堆栈平衡，以及开辟空间   
   104 0000001B 5053                <1>     multipush   ax, bx          ; 保存原始寄存器值 
   105                              <1> 
   106                              <1>     ; 获取字符
   107 0000001D B80000              <1>     mov ax, 0
   108 00000020 CD16                <1>     int 16h
   109 00000022 894606              <1>     mov [rv], ax
   110                              <1> 
   111                              <1>     ; 判断显示字符
   112 00000025 8B5E04              <1>     mov bx, [mask]
   113 00000028 83FB00              <1>     cmp bx,0
   114 0000002B 7431                <1>     jz .end
   115 0000002D 83FBFF              <1>     cmp bx, 0xffff
   116 00000030 7402                <1>     jz .printself
   117 00000032 EB19                <1>     jmp .printmask
   118                              <1> 
   119                              <1> .printself:
   120 00000034 BB0000              <1>     mov bx,0
   121 00000037 88C3                <1>     mov bl, al
   122 00000039 895E04              <1>     mov [mask], bx
   123 0000003C 89EB                <1>     mov bx, bp  ; 定位mask变量的位置
   124 0000003E 83C304              <1>     add bx, 4
   125                              <1>     printf bx, 1
   125 00000041 50                  <2>  multipush ax
   125 00000042 6A01                <2>  push %2
   125 00000044 53                  <2>  push %1
   125 00000045 E8(B300)            <2>  call proc_printf
   125 00000048 58                  <2>  pop ax
   125 00000049 58                  <2>  pop ax
   125 0000004A 58                  <2>  multipop ax
   126                              <1> 
   127 0000004B EB11                <1>     jmp .end
   128                              <1> 
   129                              <1> .printmask:
   130 0000004D 89EB                <1>     mov bx, bp  ; 定位mask变量的位置
   131 0000004F 83C304              <1>     add bx, 4   
   132                              <1>     printf bx, 1
   132 00000052 50                  <2>  multipush ax
   132 00000053 6A01                <2>  push %2
   132 00000055 53                  <2>  push %1
   132 00000056 E8(B300)            <2>  call proc_printf
   132 00000059 58                  <2>  pop ax
   132 0000005A 58                  <2>  pop ax
   132 0000005B 58                  <2>  multipop ax
   133                              <1> 
   134 0000005C EB00                <1>     jmp .end
   135                              <1> .end:
   136 0000005E 5B58                <1>     multipop   ax, bx            ; 恢复原始寄存器值
   137 00000060 C9                  <1>     leave                        ; 恢复堆栈
   138                              <1> 
   139 00000061 C3                  <1>     ret
   140                              <1>     %pop                        ; 上下文出栈
   141                              <1> 
   142                              <1> ; ---------------------------------------
   143                              <1> ; 函数说明：
   144                              <1> ;   获取一个字符
   145                              <1> ; 使用方法：
   146                              <1> ;    使用  getline, getpassword 宏
   147                              <1> ; ---------------------------------------
   148                              <1> proc_get_line:
   149                              <1>     ; 函数的一些相关定义
   150                              <1>     %push keyboard_context         ; 上下文压栈            
   151                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   152                              <1>     %arg mask:word, memaddr:word, memlen:word, rv:word  
   153                              <1> 
   154                              <1>     ; 函数体正式开始
   155 00000062 C8000000            <1>     enter       0, 0            ; 确保堆栈平衡，以及开辟空间   
   156 00000066 50535156            <1>     multipush   ax, bx, cx, si          ; 保存原始寄存器值 
   157                              <1> 
   158 0000006A B80000              <1>     mov ax, 0
   159 0000006D 89460A              <1>     mov [rv], ax
   160 00000070 8B4E08              <1>     mov cx, [memlen]
   161 00000073 8B7606              <1>     mov si, [memaddr]
   162 00000076 8B5E04              <1>     mov bx, [mask]
   163                              <1> 
   164                              <1> .again:
   165                              <1> 
   166                              <1>     ; 获取一个字符
   167                              <1>     smallcall proc_keyboard_getchar, ax, {bx}
   167                              <2> callpush %3
   167                              <3> %push callcontext
   167                              <3> %assign %$localsize %0
   167 00000079 6A00                <3> push 0
   167                              <3> %rep %0
   167                              <3>  %rotate -1
   167                              <3>  push %1
   167                              <3> %endrep
   167                              <4>  %rotate -1
   167 0000007B 53                  <4>  push %1
   167 0000007C E898FF              <2> call %1
   167                              <2> callbackpop %2
   167 0000007F 89C0                <3> mov %1, ax
   167                              <3> %rep %$localsize
   167                              <3>  pop ax
   167                              <3> %endrep
   167 00000081 58                  <4>  pop ax
   167 00000082 89C0                <3> mov ax,%1
   167 00000084 58                  <3> pop %1
   167                              <3> %pop
   168 00000085 3C0D                <1>     cmp al, 0x0d                ; 回车则结束
   169 00000087 7410                <1>     jz .end
   170                              <1> 
   171                              <1>     ; 将获取到的内容拷贝至内存中
   172 00000089 8804                <1>     mov [si], al
   173 0000008B 83C601              <1>     add si, 1
   174                              <1> 
   175                              <1>     ; 增长rv的值
   176 0000008E 8B460A              <1>     mov ax, [rv]
   177 00000091 83C001              <1>     add ax, 1
   178 00000094 89460A              <1>     mov [rv], ax
   179                              <1> 
   180 00000097 E2E0                <1>     loop .again     ; 继续
   181                              <1> 
   182                              <1> .end:
   183 00000099 5E595B58            <1>     multipop   ax, bx, cx, si    ; 恢复原始寄存器值
   184 0000009D C9                  <1>     leave                        ; 恢复堆栈
   185                              <1> 
   186 0000009E C3                  <1>     ret
   187                              <1>     %pop                        ; 上下文出栈
   188                              <1> 
   189                              <1> %endif
    12                                  
    13                                  
    14                                  org 0xA800                     ; 指示编译器 程序加载的位置
    15                                  
    16                                  section .data
    17                                       ; 欢迎字符
    18 00000000 736C656570                   defstring strSleep, strSleepLen, "sleep"
    19 00000005 77616B65207570               defstring strWakeUp, strWakeUplen, "wake up"
    20 0000000C 7761697420666F7220-          defstring strTip, strTipLen,"wait for 5S"
    20 00000015 3553               
    21                                  section .text
    22                                  start:
    23                                       intseg 0, 0
    23 00000000 50                  <1>  push ax
    23 00000001 B80000              <1>  mov ax, %1
    23 00000004 8ED8                <1>  mov ds, ax
    23 00000006 B80000              <1>  mov ax, %2
    23 00000009 8EC0                <1>  mov es, ax
    23 0000000B 58                  <1>  pop ax
    24                                       printf_init
    24 0000000C E8(0000)            <1>  call proc_printf_init
    25                                       printfclear
    25 0000000F E8(8B00)            <1>  call proc_printf_clear
    26                                       printf    strSleep, strSleepLen 
    26 00000012 50                  <1>  multipush ax
    26 00000013 6A05                <1>  push %2
    26 00000015 68[0000]            <1>  push %1
    26 00000018 E8(B300)            <1>  call proc_printf
    26 0000001B 58                  <1>  pop ax
    26 0000001C 58                  <1>  pop ax
    26 0000001D 58                  <1>  multipop ax
    27 0000001E B90500                       mov cx, 5
    28                                  waittip:
    29                                  
    30                                       printfendl
    30 00000021 E8(5500)            <1>  call proc_printfendl
    31                                       printf    strTip, strTipLen 
    31 00000024 50                  <1>  multipush ax
    31 00000025 6A0B                <1>  push %2
    31 00000027 68[0C00]            <1>  push %1
    31 0000002A E8(B300)            <1>  call proc_printf
    31 0000002D 58                  <1>  pop ax
    31 0000002E 58                  <1>  pop ax
    31 0000002F 58                  <1>  multipop ax
    32                                       ; 等待1s
    33 00000030 6A006A01E8(0000)89-          sleep 1, ax
    33 00000038 C05889C058         
    34 0000003D BB[1500]                     mov bx, strTip+9
    35 00000040 8B07                         mov ax, [bx]
    36 00000042 83E801                       sub ax, 1
    37 00000045 8907                         mov [bx], ax
    38 00000047 E2D8                         loop waittip
    39                                  
    40                                       printfendl
    40 00000049 E8(5500)            <1>  call proc_printfendl
    41                                       printf strWakeUp, strWakeUplen
    41 0000004C 50                  <1>  multipush ax
    41 0000004D 6A07                <1>  push %2
    41 0000004F 68[0500]            <1>  push %1
    41 00000052 E8(B300)            <1>  call proc_printf
    41 00000055 58                  <1>  pop ax
    41 00000056 58                  <1>  pop ax
    41 00000057 58                  <1>  multipop ax
    42                                  
    43                                  
    44                                       ; 结束
    45 00000058 E8(0000)6A006AFFE8-          getchar ax
    45 00000060 (1700)89C05889C058 
    46 00000068 CD88                         int 88h
    47                                  
    48 0000006A EBFE                         jmp $ ; 无限循环
    49                                  
