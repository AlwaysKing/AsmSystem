     1                                  ; ================================================================
     2                                  ; 这是运行在裸机上的ProgramLoader代码，NASM的16位汇编完成
     3                                  ; 内存加载地址：07d00h 
     4                                  ; 完成功能：
     5                                  ;    1. 加载位于64扇区的文件索引，显示可启动的程序列表
     6                                  ;    2. 提供子程序退出到本程序的INT 88h服务
     7                                  ;    3. 接受用户指令调用子程序
     8                                  ; ================================================================
     9                                  %include "COMMON.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     通用功能的
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_common
     8                              <1> %define lib_common
     9                              <1> 
    10                              <1> ; ---------------------------------------
    11                              <1> ; 宏说明：
    12                              <1> ;   初始化段寄存器
    13                              <1> ; 使用方法：
    14                              <1> ;   intseg  DS,ES
    15                              <1> ; ---------------------------------------
    16                              <1> %macro intseg 2
    17                              <1>     push ax
    18                              <1>     mov ax, %1           
    19                              <1>     mov ds, ax   
    20                              <1>     mov ax, %2           
    21                              <1>     mov es, ax
    22                              <1>     pop ax
    23                              <1> %endmacro 
    24                              <1> 
    25                              <1> ; ---------------------------------------
    26                              <1> ; 宏说明：
    27                              <1> ;   将指定的一些列寄存器压栈
    28                              <1> ; 使用方法：
    29                              <1> ;   multipush    ax,bx,cs,ds,.....
    30                              <1> ; ---------------------------------------
    31                              <1> %macro  multipush 1-*.nolist
    32                              <1> %rep  %0                
    33                              <1>     push    %1          
    34                              <1>     %rotate 1          
    35                              <1> %endrep              
    36                              <1> %endmacro 
    37                              <1> 
    38                              <1> ; ---------------------------------------
    39                              <1> ; 宏说明：
    40                              <1> ;   将指定的一些列寄存器出栈
    41                              <1> ; 使用方法：
    42                              <1> ;   multipop    ax,bx,cs,ds,.....
    43                              <1> ; 其它说明：
    44                              <1> ;   寄存器顺序与使用 multipush 的时候需保持一致
    45                              <1> ; ---------------------------------------
    46                              <1> %macro  multipop 1-*.nolist
    47                              <1> %rep %0          
    48                              <1>     %rotate -1               
    49                              <1>     pop     %1          
    50                              <1> %endrep               
    51                              <1> %endmacro 
    52                              <1> 
    53                              <1> ; ---------------------------------------
    54                              <1> ; 宏说明：
    55                              <1> ;   简化调用时候的传参，此宏定义必须 与 callbackpop 搭配使用
    56                              <1> ; 使用方法：
    57                              <1> ;   call    参数1, 参数2，...
    58                              <1> ; ---------------------------------------
    59                              <1> %macro  callpush 1-*;.nolist
    60                              <1> %push   callcontext
    61                              <1> %assign %$localsize %0
    62                              <1> push 0
    63                              <1> %rep %0          
    64                              <1>     %rotate -1
    65                              <1>     push    %1          
    66                              <1> %endrep       
    67                              <1> %endmacro 
    68                              <1> 
    69                              <1> ; ---------------------------------------
    70                              <1> ; 宏说明：
    71                              <1> ;   简化调用时候的传参，此宏定义必须 与 callpush 搭配使用
    72                              <1> ; 使用方法：
    73                              <1> ;   call    返回值
    74                              <1> ; ---------------------------------------
    75                              <1> %macro  callbackpop 1
    76                              <1> mov %1, ax
    77                              <1> %rep %$localsize          
    78                              <1>     pop ax
    79                              <1> %endrep
    80                              <1> mov ax,%1
    81                              <1> pop %1
    82                              <1> %pop
    83                              <1> %endmacro 
    84                              <1> 
    85                              <1> ; ---------------------------------------
    86                              <1> ; 宏说明：
    87                              <1> ;   封装了 callpush 和  callbackpop 的调用，之后再也不用管参数的压栈顺序了
    88                              <1> ; 使用方法：
    89                              <1> ;   call    要调用的函数, 返回值存储地址，{参数1, 参数2, 参数3}
    90                              <1> ; ---------------------------------------
    91                              <1> %macro smallcall 3
    92                              <1> callpush %3
    93                              <1> call %1
    94                              <1> callbackpop %2
    95                              <1> %endmacro
    96                              <1> 
    97                              <1> ; ---------------------------------------
    98                              <1> ; 宏说明：
    99                              <1> ;   将指定的段的段地址保存到指定寄存器中
   100                              <1> ; 使用方法：
   101                              <1> ;    myseg    段寄存器, 段名称
   102                              <1> ; ---------------------------------------
   103                              <1> %macro  myseg 2.nolist         
   104                              <1>     multipush   ax
   105                              <1>     ;
   106                              <1>     mov ax, section.%2.start
   107                              <1>     mov %1,ax
   108                              <1>     ;
   109                              <1>     multipop    ax             
   110                              <1> %endmacro 
   111                              <1> 
   112                              <1> 
   113                              <1> ; ---------------------------------------
   114                              <1> ; 宏说明：
   115                              <1> ;   将指定值复制到指定内存中, 安全函数，不会改变借用的寄存器的值
   116                              <1> ; 使用方法：
   117                              <1> ;    memset    借用的寄存器, 内存地址, 值
   118                              <1> ; ---------------------------------------
   119                              <1> %macro  memset 3.nolist         
   120                              <1>     multipush   %1
   121                              <1>     ;
   122                              <1>     mov %1, %3
   123                              <1>     mov %2,%1
   124                              <1>     ;
   125                              <1>     multipop    %1             
   126                              <1> %endmacro 
   127                              <1> 
   128                              <1> ; ---------------------------------------
   129                              <1> ; 宏说明：
   130                              <1> ;   将指定值复制到指定内存中, 与memset的不同是，不安全函数，会改变借用的寄存器的值
   131                              <1> ; 使用方法：
   132                              <1> ;    memset_byax    借用的寄存器, 内存地址, 值
   133                              <1> ; ---------------------------------------
   134                              <1> %macro  memset_unsafe 3.nolist         
   135                              <1>     ;
   136                              <1>     mov %1, %3
   137                              <1>     mov %2, %1
   138                              <1>     ;          
   139                              <1> %endmacro 
   140                              <1> 
   141                              <1> %endif
    10                                  %include "PRINT.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 这是关于打印信息的相关宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     字符串打赢的宏定义
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_print
     8                              <1> %define lib_print
     9                              <1> 
    10                              <1> %include "COMMON.ASM"
     1                              <2> ; ================================================================
     2                              <2> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <2> ; 完成功能：
     4                              <2> ;     通用功能的
     5                              <2> ; ================================================================
     6                              <2> 
     7                              <2> %ifndef lib_common
     8                              <2> %define lib_common
     9                              <2> 
    10                              <2> ; ---------------------------------------
    11                              <2> ; 宏说明：
    12                              <2> ;   初始化段寄存器
    13                              <2> ; 使用方法：
    14                              <2> ;   intseg  DS,ES
    15                              <2> ; ---------------------------------------
    16                              <2> %macro intseg 2
    17                              <2>     push ax
    18                              <2>     mov ax, %1           
    19                              <2>     mov ds, ax   
    20                              <2>     mov ax, %2           
    21                              <2>     mov es, ax
    22                              <2>     pop ax
    23                              <2> %endmacro 
    24                              <2> 
    25                              <2> ; ---------------------------------------
    26                              <2> ; 宏说明：
    27                              <2> ;   将指定的一些列寄存器压栈
    28                              <2> ; 使用方法：
    29                              <2> ;   multipush    ax,bx,cs,ds,.....
    30                              <2> ; ---------------------------------------
    31                              <2> %macro  multipush 1-*.nolist
    32                              <2> %rep  %0                
    33                              <2>     push    %1          
    34                              <2>     %rotate 1          
    35                              <2> %endrep              
    36                              <2> %endmacro 
    37                              <2> 
    38                              <2> ; ---------------------------------------
    39                              <2> ; 宏说明：
    40                              <2> ;   将指定的一些列寄存器出栈
    41                              <2> ; 使用方法：
    42                              <2> ;   multipop    ax,bx,cs,ds,.....
    43                              <2> ; 其它说明：
    44                              <2> ;   寄存器顺序与使用 multipush 的时候需保持一致
    45                              <2> ; ---------------------------------------
    46                              <2> %macro  multipop 1-*.nolist
    47                              <2> %rep %0          
    48                              <2>     %rotate -1               
    49                              <2>     pop     %1          
    50                              <2> %endrep               
    51                              <2> %endmacro 
    52                              <2> 
    53                              <2> ; ---------------------------------------
    54                              <2> ; 宏说明：
    55                              <2> ;   简化调用时候的传参，此宏定义必须 与 callbackpop 搭配使用
    56                              <2> ; 使用方法：
    57                              <2> ;   call    参数1, 参数2，...
    58                              <2> ; ---------------------------------------
    59                              <2> %macro  callpush 1-*;.nolist
    60                              <2> %push   callcontext
    61                              <2> %assign %$localsize %0
    62                              <2> push 0
    63                              <2> %rep %0          
    64                              <2>     %rotate -1
    65                              <2>     push    %1          
    66                              <2> %endrep       
    67                              <2> %endmacro 
    68                              <2> 
    69                              <2> ; ---------------------------------------
    70                              <2> ; 宏说明：
    71                              <2> ;   简化调用时候的传参，此宏定义必须 与 callpush 搭配使用
    72                              <2> ; 使用方法：
    73                              <2> ;   call    返回值
    74                              <2> ; ---------------------------------------
    75                              <2> %macro  callbackpop 1
    76                              <2> mov %1, ax
    77                              <2> %rep %$localsize          
    78                              <2>     pop ax
    79                              <2> %endrep
    80                              <2> mov ax,%1
    81                              <2> pop %1
    82                              <2> %pop
    83                              <2> %endmacro 
    84                              <2> 
    85                              <2> ; ---------------------------------------
    86                              <2> ; 宏说明：
    87                              <2> ;   封装了 callpush 和  callbackpop 的调用，之后再也不用管参数的压栈顺序了
    88                              <2> ; 使用方法：
    89                              <2> ;   call    要调用的函数, 返回值存储地址，{参数1, 参数2, 参数3}
    90                              <2> ; ---------------------------------------
    91                              <2> %macro smallcall 3
    92                              <2> callpush %3
    93                              <2> call %1
    94                              <2> callbackpop %2
    95                              <2> %endmacro
    96                              <2> 
    97                              <2> ; ---------------------------------------
    98                              <2> ; 宏说明：
    99                              <2> ;   将指定的段的段地址保存到指定寄存器中
   100                              <2> ; 使用方法：
   101                              <2> ;    myseg    段寄存器, 段名称
   102                              <2> ; ---------------------------------------
   103                              <2> %macro  myseg 2.nolist         
   104                              <2>     multipush   ax
   105                              <2>     ;
   106                              <2>     mov ax, section.%2.start
   107                              <2>     mov %1,ax
   108                              <2>     ;
   109                              <2>     multipop    ax             
   110                              <2> %endmacro 
   111                              <2> 
   112                              <2> 
   113                              <2> ; ---------------------------------------
   114                              <2> ; 宏说明：
   115                              <2> ;   将指定值复制到指定内存中, 安全函数，不会改变借用的寄存器的值
   116                              <2> ; 使用方法：
   117                              <2> ;    memset    借用的寄存器, 内存地址, 值
   118                              <2> ; ---------------------------------------
   119                              <2> %macro  memset 3.nolist         
   120                              <2>     multipush   %1
   121                              <2>     ;
   122                              <2>     mov %1, %3
   123                              <2>     mov %2,%1
   124                              <2>     ;
   125                              <2>     multipop    %1             
   126                              <2> %endmacro 
   127                              <2> 
   128                              <2> ; ---------------------------------------
   129                              <2> ; 宏说明：
   130                              <2> ;   将指定值复制到指定内存中, 与memset的不同是，不安全函数，会改变借用的寄存器的值
   131                              <2> ; 使用方法：
   132                              <2> ;    memset_byax    借用的寄存器, 内存地址, 值
   133                              <2> ; ---------------------------------------
   134                              <2> %macro  memset_unsafe 3.nolist         
   135                              <2>     ;
   136                              <2>     mov %1, %3
   137                              <2>     mov %2, %1
   138                              <2>     ;          
   139                              <2> %endmacro 
   140                              <2> 
   141                              <2> %endif
    11                              <1> 
    12                              <1> ; ================================================================
    13                              <1> ; 调用宏定义
    14                              <1> ; 所有函数都使用对应的宏定义来调用
    15                              <1> ; ================================================================
    16                              <1> %macro printf_init 0
    17                              <1>     call proc_printf_init
    18                              <1> %endmacro
    19                              <1> 
    20                              <1> 
    21                              <1> ; ---------------------------------------
    22                              <1> ; 宏说明：
    23                              <1> ;   清楚屏幕内容
    24                              <1> ; 使用方法：
    25                              <1> ;   printfreturn    
    26                              <1> ; ---------------------------------------
    27                              <1> %macro printfclear 0
    28                              <1>     call proc_printf_clear
    29                              <1> %endmacro
    30                              <1> 
    31                              <1> ; ---------------------------------------
    32                              <1> ; 宏说明：
    33                              <1> ;   回到行的开头
    34                              <1> ; 使用方法：
    35                              <1> ;   printfreturn    
    36                              <1> ; ---------------------------------------
    37                              <1> %macro printfreturn 0
    38                              <1>     call proc_printfreturn
    39                              <1> %endmacro
    40                              <1> 
    41                              <1> ; ---------------------------------------
    42                              <1> ; 宏说明：
    43                              <1> ;   换到下一行
    44                              <1> ; 使用方法：
    45                              <1> ;   printfaddlen    长度
    46                              <1> ; ---------------------------------------
    47                              <1> %macro printfenter 0
    48                              <1>     call proc_printfenter
    49                              <1> %endmacro
    50                              <1> 
    51                              <1> 
    52                              <1> ; ---------------------------------------
    53                              <1> ; 宏说明：
    54                              <1> ;   回车换行
    55                              <1> ; 使用方法：
    56                              <1> ;   printfendl    长度
    57                              <1> ; ---------------------------------------
    58                              <1> %macro printfendl 0
    59                              <1>     call proc_printfendl
    60                              <1> %endmacro
    61                              <1> 
    62                              <1> 
    63                              <1> ; ---------------------------------------
    64                              <1> ; 宏说明：
    65                              <1> ;   增加每一行的打印起始点坐标
    66                              <1> ; 使用方法：
    67                              <1> ;   printfaddlen    长度
    68                              <1> ; ---------------------------------------
    69                              <1> %macro printfaddlen 1
    70                              <1>     multipush ax
    71                              <1>     push %1
    72                              <1>     call proc_printfaddlen
    73                              <1>     pop ax
    74                              <1>     multipop ax
    75                              <1> %endmacro
    76                              <1> 
    77                              <1> ; ---------------------------------------
    78                              <1> ; 宏说明：
    79                              <1> ;   打印一段字符串
    80                              <1> ; 使用方法：
    81                              <1> ;   printf    字符串起始地址,字符串的长度
    82                              <1> ; ---------------------------------------
    83                              <1> %macro printf 2
    84                              <1>     multipush ax
    85                              <1>     push %2
    86                              <1>     push %1
    87                              <1>     call proc_printf
    88                              <1>     pop ax
    89                              <1>     pop ax
    90                              <1>     multipop ax
    91                              <1> %endmacro
    92                              <1> 
    93                              <1> ; ---------------------------------------
    94                              <1> ; 宏说明：
    95                              <1> ;   打印一段字符串
    96                              <1> ; 使用方法：
    97                              <1> ;   printf    字符串起始地址,字符串的长度, 颜色
    98                              <1> ; 其他说明：
    99                              <1> ;       颜色
   100                              <1> ;        0	黑色		8	灰色	
   101                              <1> ;        1	蓝色		9	亮蓝色	 
   102                              <1> ;        2	绿色		A	亮绿色	
   103                              <1> ;        3	青色		B	亮青色	
   104                              <1> ;        4	红色		C	亮红色	
   105                              <1> ;        5	紫红色		D	亮紫红色	
   106                              <1> ;        6	棕色		E	黄色	
   107                              <1> ;        7	银色	 	F	白色	
   108                              <1> ; ---------------------------------------
   109                              <1> %macro printf_color 3
   110                              <1>     multipush ax
   111                              <1>     push %3
   112                              <1>     push %2
   113                              <1>     push %1
   114                              <1>     call proc_printf_color
   115                              <1>     pop ax
   116                              <1>     pop ax
   117                              <1>     pop ax
   118                              <1>     multipop ax
   119                              <1> %endmacro
   120                              <1> 
   121                              <1> 
   122                              <1> ; ================================================================
   123                              <1> ; 调用函数
   124                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
   125                              <1> ; ================================================================
   126                              <1> 
   127                              <1> section .bss
   128 00000000 <res 00000001>      <1>     lib_string_hang resb 1              ; 最多25行
   129 00000001 <res 00000001>      <1>     lib_string_lie  resb 1              ; 一行最多80个字符
   130                              <1> section lib_print_section
   131                              <1> 
   132                              <1> ; ---------------------------------------
   133                              <1> ; 函数说明：
   134                              <1> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   135                              <1> ; 使用方法：
   136                              <1> ;   printfaddlen    长度
   137                              <1> ; ---------------------------------------
   138                              <1> proc_printf_init:
   139 00000000 C8000000            <1>     enter 0, 0
   140 00000004 50                  <1>     multipush   ax
   141 00000005 B80000              <1>     mov ax, 0
   142 00000008 A2[0000]            <1>     mov [lib_string_hang], al
   143 0000000B A2[0100]            <1>     mov [lib_string_lie], al
   144 0000000E 58                  <1>     multipop   ax
   145 0000000F C9                  <1>     leave
   146 00000010 C3                  <1>     ret
   147                              <1> 
   148                              <1> ; ---------------------------------------
   149                              <1> ; 函数说明：
   150                              <1> ;   重新设定光标位置
   151                              <1> ; 使用方法：
   152                              <1> ;   printfaddlen    长度
   153                              <1> ; ---------------------------------------
   154                              <1> proc_printf_pos:
   155 00000011 C8000000            <1>     enter 0, 0
   156 00000015 505352              <1>     multipush ax,bx,dx
   157 00000018 B80000              <1>     mov ax,0
   158 0000001B B402                <1>     mov ah, 02h
   159 0000001D B700                <1>     mov bh,0
   160 0000001F 8A36[0000]          <1>     mov dh, [lib_string_hang]
   161 00000023 8A16[0100]          <1>     mov dl, [lib_string_lie]
   162 00000027 CD10                <1>     int 10h
   163 00000029 5A5B58              <1>     multipop ax,bx,dx
   164 0000002C C9                  <1>     leave
   165 0000002D C3                  <1>     ret
   166                              <1> 
   167                              <1> ; ---------------------------------------
   168                              <1> ; 函数说明：
   169                              <1> ;   回到行的开头
   170                              <1> ; 使用方法：
   171                              <1> ;   printfreturn    
   172                              <1> ; ---------------------------------------
   173                              <1> proc_printfreturn:
   174 0000002E C8000000            <1>     enter 0, 0
   175 00000032 50                  <1>     multipush   ax
   176 00000033 B000                <1>     mov al, 0 
   177 00000035 A2[0100]            <1>     mov [lib_string_lie],  al
   178 00000038 E8D6FF              <1>     call proc_printf_pos
   179 0000003B 58                  <1>     multipop   ax   
   180 0000003C C9                  <1>     leave
   181 0000003D C3                  <1>     ret
   182                              <1> ; ---------------------------------------
   183                              <1> ; 函数说明：
   184                              <1> ;   换到下一行
   185                              <1> ; 使用方法：
   186                              <1> ;   printfaddlen    长度
   187                              <1> ; ---------------------------------------
   188                              <1> proc_printfenter:
   189 0000003E C8000000            <1>     enter 0, 0
   190 00000042 50                  <1>     multipush   ax
   191 00000043 A0[0000]            <1>     mov al, [lib_string_hang] 
   192 00000046 3C18                <1>     cmp al, 24                         ; 如果 lib_string_hang = 24，那么不能再增加了
   193 00000048 7408                <1>     jz  .donothing
   194 0000004A 0401                <1>     add al, 1                          ; 否则 AL+1
   195 0000004C A2[0000]            <1>     mov [lib_string_hang],  al
   196 0000004F E8BFFF              <1>     call proc_printf_pos
   197                              <1> .donothing:
   198 00000052 58                  <1>     multipop   ax   
   199 00000053 C9                  <1>     leave
   200 00000054 C3                  <1>     ret
   201                              <1> 
   202                              <1> ; ---------------------------------------
   203                              <1> ; 函数说明：
   204                              <1> ;   回车换行
   205                              <1> ; 使用方法：
   206                              <1> ;   printfendl    长度
   207                              <1> ; ---------------------------------------
   208                              <1> proc_printfendl:
   209 00000055 C8000000            <1>     enter 0, 0
   210                              <1>     printfenter
   210 00000059 E8E2FF              <2>  call proc_printfenter
   211                              <1>     printfreturn
   211 0000005C E8CFFF              <2>  call proc_printfreturn
   212 0000005F C9                  <1>     leave
   213 00000060 C3                  <1>     ret
   214                              <1> 
   215                              <1> ; ---------------------------------------
   216                              <1> ; 函数说明：
   217                              <1> ;   增加每一行的打印起始点坐标
   218                              <1> ; 使用方法：
   219                              <1> ;   printfaddlen    长度
   220                              <1> ; ---------------------------------------
   221                              <1> proc_printfaddlen:
   222                              <1>     %push disk_io_context         ; 上下文压栈            
   223                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   224                              <1>     %arg length:word ; 定义参数
   225                              <1> 
   226 00000061 C8000000            <1>     enter 0, 0
   227 00000065 50                  <1>     multipush   ax
   228 00000066 B80000              <1>     mov ax, 0
   229 00000069 A0[0100]            <1>     mov al,[lib_string_lie]
   230 0000006C 034604              <1>     add ax, [length]
   231                              <1> .again:
   232 0000006F 83F850              <1>     cmp ax, 80
   233 00000072 7709                <1>     ja .dayu
   234 00000074 7202                <1>     jb .xiaoyu
   235 00000076 EB0D                <1>     jmp .dengyu
   236                              <1> .xiaoyu:   ; 小于就结束了
   237 00000078 A2[0100]            <1>     mov [lib_string_lie], al 
   238 0000007B EB0B                <1>     jmp .end           
   239                              <1> .dayu:     ; 大于，还需要循环
   240 0000007D 83E850              <1>     sub ax, 80
   241                              <1>     printfendl
   241 00000080 E8D2FF              <2>  call proc_printfendl
   242 00000083 EBEA                <1>     jmp .again
   243                              <1> .dengyu:   ; 等于也结束了
   244                              <1>     printfendl
   244 00000085 E8CDFF              <2>  call proc_printfendl
   245                              <1> .end:
   246 00000088 58                  <1>     multipop   ax
   247 00000089 C9                  <1>     leave
   248 0000008A C3                  <1>     ret
   249                              <1> 
   250                              <1>     %pop
   251                              <1> 
   252                              <1> ; ---------------------------------------
   253                              <1> ; 函数说明：
   254                              <1> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   255                              <1> ; 使用方法：
   256                              <1> ;   printfaddlen    长度
   257                              <1> ; ---------------------------------------
   258                              <1> proc_printf_clear:
   259 0000008B C8000000            <1>     enter 0, 0
   260 0000008F 50515253            <1>     multipush   ax,cx,dx,bx
   261                              <1> 
   262 00000093 B406                <1>     mov ah,0x06
   263 00000095 B000                <1>     mov al,0   ;清窗口
   264 00000097 B90000              <1>     mov cx,0   ;左上角的行号
   265 0000009A B619                <1>     mov dh,25  ;右下角的行号
   266 0000009C B250                <1>     mov dl,80  ;右下角的行号
   267 0000009E B70F                <1>     mov bh,0x0f;属性为黑底白字
   268 000000A0 CD10                <1>     int 0x10
   269                              <1> 
   270 000000A2 B000                <1>     mov al, 0 
   271 000000A4 A2[0100]            <1>     mov [lib_string_lie],  al
   272 000000A7 A2[0000]            <1>     mov [lib_string_hang],  al
   273 000000AA E864FF              <1>     call proc_printf_pos
   274                              <1> 
   275 000000AD 5B5A5958            <1>     multipop   ax,cx,dx,bx
   276 000000B1 C9                  <1>     leave
   277 000000B2 C3                  <1>     ret
   278                              <1> 
   279                              <1> ; ---------------------------------------
   280                              <1> ; 函数说明：
   281                              <1> ;   打印一段字符串
   282                              <1> ; 使用方法：
   283                              <1> ;   printf    字符串起始地址,字符串的长度
   284                              <1> ; ---------------------------------------
   285                              <1> proc_printf:
   286                              <1>     %push disk_io_context         ; 上下文压栈            
   287                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   288                              <1>     %arg offset:word, length:word ; 定义参数
   289                              <1> 
   290 000000B3 C8000000            <1>     enter 0, 0
   291 000000B7 5053515255          <1>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   292                              <1> 
   293 000000BC 8B4E06              <1>     mov cx, [length]                ; CX = 串长度
   294 000000BF BB0F00              <1>     mov bx, 000fh                   ; 页号为0(BH = 0) 黑底白字(BL = 0Fh,高亮)
   295 000000C2 8A16[0100]          <1>     mov dl, [lib_string_lie]        ; 列
   296 000000C6 8A36[0000]          <1>     mov dh, [lib_string_hang]       ; 行
   297                              <1> 
   298 000000CA 8B4604              <1>     mov ax, [offset]
   299 000000CD 55                  <1>     push bp
   300 000000CE 89C5                <1>     mov bp, ax                      ; ES:BP = 串地址
   301 000000D0 B80113              <1>     mov ax, 01301h                  ; AH = 13, AL = 01h
   302 000000D3 CD10                <1>     int 10h ; 10h 号中断
   303 000000D5 5D                  <1>     pop bp
   304                              <1> 
   305 000000D6 8B4E06              <1>     mov cx, [length]
   306                              <1>     printfaddlen    cx
   306 000000D9 50                  <2>  multipush ax
   306 000000DA 51                  <2>  push %1
   306 000000DB E883FF              <2>  call proc_printfaddlen
   306 000000DE 58                  <2>  pop ax
   306 000000DF 58                  <2>  multipop ax
   307                              <1> 
   308 000000E0 5D5A595B58          <1>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   309 000000E5 C9                  <1>     leave
   310 000000E6 C3                  <1>     ret
   311                              <1> 
   312                              <1>     %pop
   313                              <1> 
   314                              <1> ; ---------------------------------------
   315                              <1> ; 函数说明：
   316                              <1> ;   打印一段字符串
   317                              <1> ; 使用方法：
   318                              <1> ;   printf    字符串起始地址,字符串的长度, 颜色
   319                              <1> ; 其他说明：
   320                              <1> ;       颜色
   321                              <1> ;        0	黑色		8	灰色	
   322                              <1> ;        1	蓝色		9	亮蓝色	 
   323                              <1> ;        2	绿色		A	亮绿色	
   324                              <1> ;        3	青色		B	亮青色	
   325                              <1> ;        4	红色		C	亮红色	
   326                              <1> ;        5	紫红色		D	亮紫红色	
   327                              <1> ;        6	棕色		E	黄色	
   328                              <1> ;        7	银色	 	F	白色	
   329                              <1> ; ---------------------------------------
   330                              <1> proc_printf_color:
   331                              <1>     %push disk_io_context         ; 上下文压栈            
   332                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   333                              <1>     %arg offset:word, length:word, color:word       ; 定义参数
   334                              <1> 
   335 000000E7 C8000000            <1>     enter 0, 0
   336 000000EB 5053515255          <1>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   337 000000F0 8B4E06              <1>     mov cx, [length]                ; CX = 串长度
   338                              <1> 
   339 000000F3 8B5E08              <1>     mov bx, [color]                 ; 前景色和背景色
   340 000000F6 B700                <1>     mov bh, 0h                      ; 页号为0(BH = 0) 
   341 000000F8 8A16[0100]          <1>     mov dl, [lib_string_lie]        ; 列
   342 000000FC 8A36[0000]          <1>     mov dh, [lib_string_hang]       ; 行
   343                              <1> 
   344 00000100 8B4604              <1>     mov ax, [offset]
   345 00000103 55                  <1>     push bp
   346 00000104 89C5                <1>     mov bp, ax                      ; ES:BP = 串地址
   347 00000106 B80113              <1>     mov ax, 01301h                  ; AH = 13, AL = 01h
   348 00000109 CD10                <1>     int 10h ; 10h 号中断
   349 0000010B 5D                  <1>     pop bp
   350                              <1>     
   351 0000010C 8B4E06              <1>     mov cx, [length]
   352                              <1>     printfaddlen    cx
   352 0000010F 50                  <2>  multipush ax
   352 00000110 51                  <2>  push %1
   352 00000111 E84DFF              <2>  call proc_printfaddlen
   352 00000114 58                  <2>  pop ax
   352 00000115 58                  <2>  multipop ax
   353                              <1> 
   354 00000116 5D5A595B58          <1>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   355 0000011B C9                  <1>     leave
   356 0000011C C3                  <1>     ret
   357                              <1> 
   358                              <1>     %pop
   359                              <1> %endif
    11                                  %include "STRING.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     通用功能的
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_string
     8                              <1> %define lib_string
     9                              <1> 
    10                              <1> ; ================================================================
    11                              <1> ; 调用宏定义
    12                              <1> ; 所有函数都使用对应的宏定义来调用
    13                              <1> ; ================================================================
    14                              <1> 
    15                              <1> ; ---------------------------------------
    16                              <1> ; 宏说明：
    17                              <1> ;   简化字符串的定义，一般用在 data 段中
    18                              <1> ; 使用方法：
    19                              <1> ;    defstring    字符串名称, 字符串长度的名称，字符串内容
    20                              <1> ; ---------------------------------------
    21                              <1> %macro  defstring 3.nolist       
    22                              <1>     ;
    23                              <1>     %1: db %3         ; 定义文字的内存
    24                              <1>     %2 equ $-%1       ; 计算文字长度
    25                              <1>     ;             
    26                              <1> %endmacro 
    27                              <1> 
    28                              <1> ; ---------------------------------------
    29                              <1> ; 宏说明：
    30                              <1> ;   字符串比较
    31                              <1> ; 使用方法：
    32                              <1> ;    strstr    字符串名称1, 字符串1长度, 字符串名称2， 字符串2长度, 返回值存储寄存器
    33                              <1> ;    返回值     0 表示一致   其他表示不一致
    34                              <1> ; ---------------------------------------
    35                              <1> %macro  strcmp  5 ;.nolist       
    36                              <1>     smallcall proc_strcmp, %5, {%1,%2,%3,%4}
    37                              <1> %endmacro 
    38                              <1> 
    39                              <1> ; ================================================================
    40                              <1> ; 调用函数
    41                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
    42                              <1> ; ================================================================
    43                              <1> section lib_string_section
    44                              <1> ; ---------------------------------------
    45                              <1> ; 函数说明：
    46                              <1> ;   字符串比较
    47                              <1> ; 使用方法：
    48                              <1> ;    strstr    字符串名称1, 字符串1长度, 字符串名称2， 字符串2长度, 返回值存储寄存器
    49                              <1> ;    返回值     0 表示一致   其他表示不一致
    50                              <1> ; ---------------------------------------
    51                              <1> proc_strcmp:
    52                              <1>     ; 函数的一些相关定义
    53                              <1>     %push disk_io_context         ; 上下文压栈            
    54                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
    55                              <1>     %assign %$localsize 16 
    56                              <1>     %arg src:word, srclen:word, des:word, deslen:word, rv:word    ; 定义参数
    57                              <1> 
    58                              <1>     ; 函数体正式开始
    59 00000000 C8100000            <1>     enter       16,    0   ; 确保堆栈平衡，以及开辟空间   
    60 00000004 5051531E56          <1>     multipush   ax,cx,bx,ds,si            ; 保存原始寄存器值 
    61                              <1> 
    62                              <1>     ; 先比较字符串长度
    63 00000009 8B4606              <1>     mov ax, [srclen]
    64 0000000C 2B460A              <1>     sub ax, [deslen]
    65 0000000F 7514                <1>     jnz  .noequal
    66                              <1> 
    67                              <1>     ; 长度相等开始比较字符串
    68                              <1> .lenequal:
    69                              <1> 
    70                              <1> 
    71 00000011 8B7604              <1>     mov si, [src]
    72 00000014 8B7E08              <1>     mov di, [des]
    73 00000017 8B4E06              <1>     mov cx, [srclen]
    74                              <1> 
    75 0000001A F3A6                <1>     repz cmpsb
    76                              <1>     ; 标志寄存器不等于0 表示两个字符不相等
    77 0000001C 7507                <1>     jnz .noequal
    78                              <1> 
    79                              <1>     ; 判断了标志寄存器在判断cx 是不是0
    80 0000001E 83E900              <1>     sub cx, 0
    81 00000021 7502                <1>     jnz .noequal
    82                              <1> 
    83                              <1>     ; 到此基本认为是相等了
    84 00000023 EB08                <1>     jmp .equal
    85                              <1> 
    86                              <1>     ; 不相等
    87                              <1> .noequal:
    88 00000025 B80100              <1>     mov ax, 1
    89 00000028 89460C              <1>     mov [rv], ax
    90 0000002B EB08                <1>     jmp .end
    91                              <1> 
    92                              <1>     ; 不等
    93                              <1> .equal:
    94 0000002D B80000              <1>      mov ax, 0
    95 00000030 89460C              <1>     mov [rv], ax
    96 00000033 EB00                <1>     jmp .end
    97                              <1> 
    98                              <1> .end:
    99 00000035 5E1F5B5958          <1>     multipop   ax,cx,bx,ds,si               ; 恢复原始寄存器值
   100 0000003A C9                  <1>     leave                                   ; 恢复堆栈
   101                              <1> 
   102 0000003B C3                  <1>     ret
   103                              <1>     %pop                        ; 上下文出栈
   104                              <1> %endif
    12                                  %include "DISK.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 这是关于磁盘操作的相关宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     磁盘的读写操作
     5                              <1> ; ================================================================
     6                              <1> %ifndef lib_disk
     7                              <1> %define lib_disk
     8                              <1> %include "COMMON.ASM"
     1                              <2> ; ================================================================
     2                              <2> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <2> ; 完成功能：
     4                              <2> ;     通用功能的
     5                              <2> ; ================================================================
     6                              <2> 
     7                              <2> %ifndef lib_common
     8                              <2> %define lib_common
     9                              <2> 
    10                              <2> ; ---------------------------------------
    11                              <2> ; 宏说明：
    12                              <2> ;   初始化段寄存器
    13                              <2> ; 使用方法：
    14                              <2> ;   intseg  DS,ES
    15                              <2> ; ---------------------------------------
    16                              <2> %macro intseg 2
    17                              <2>     push ax
    18                              <2>     mov ax, %1           
    19                              <2>     mov ds, ax   
    20                              <2>     mov ax, %2           
    21                              <2>     mov es, ax
    22                              <2>     pop ax
    23                              <2> %endmacro 
    24                              <2> 
    25                              <2> ; ---------------------------------------
    26                              <2> ; 宏说明：
    27                              <2> ;   将指定的一些列寄存器压栈
    28                              <2> ; 使用方法：
    29                              <2> ;   multipush    ax,bx,cs,ds,.....
    30                              <2> ; ---------------------------------------
    31                              <2> %macro  multipush 1-*.nolist
    32                              <2> %rep  %0                
    33                              <2>     push    %1          
    34                              <2>     %rotate 1          
    35                              <2> %endrep              
    36                              <2> %endmacro 
    37                              <2> 
    38                              <2> ; ---------------------------------------
    39                              <2> ; 宏说明：
    40                              <2> ;   将指定的一些列寄存器出栈
    41                              <2> ; 使用方法：
    42                              <2> ;   multipop    ax,bx,cs,ds,.....
    43                              <2> ; 其它说明：
    44                              <2> ;   寄存器顺序与使用 multipush 的时候需保持一致
    45                              <2> ; ---------------------------------------
    46                              <2> %macro  multipop 1-*.nolist
    47                              <2> %rep %0          
    48                              <2>     %rotate -1               
    49                              <2>     pop     %1          
    50                              <2> %endrep               
    51                              <2> %endmacro 
    52                              <2> 
    53                              <2> ; ---------------------------------------
    54                              <2> ; 宏说明：
    55                              <2> ;   简化调用时候的传参，此宏定义必须 与 callbackpop 搭配使用
    56                              <2> ; 使用方法：
    57                              <2> ;   call    参数1, 参数2，...
    58                              <2> ; ---------------------------------------
    59                              <2> %macro  callpush 1-*;.nolist
    60                              <2> %push   callcontext
    61                              <2> %assign %$localsize %0
    62                              <2> push 0
    63                              <2> %rep %0          
    64                              <2>     %rotate -1
    65                              <2>     push    %1          
    66                              <2> %endrep       
    67                              <2> %endmacro 
    68                              <2> 
    69                              <2> ; ---------------------------------------
    70                              <2> ; 宏说明：
    71                              <2> ;   简化调用时候的传参，此宏定义必须 与 callpush 搭配使用
    72                              <2> ; 使用方法：
    73                              <2> ;   call    返回值
    74                              <2> ; ---------------------------------------
    75                              <2> %macro  callbackpop 1
    76                              <2> mov %1, ax
    77                              <2> %rep %$localsize          
    78                              <2>     pop ax
    79                              <2> %endrep
    80                              <2> mov ax,%1
    81                              <2> pop %1
    82                              <2> %pop
    83                              <2> %endmacro 
    84                              <2> 
    85                              <2> ; ---------------------------------------
    86                              <2> ; 宏说明：
    87                              <2> ;   封装了 callpush 和  callbackpop 的调用，之后再也不用管参数的压栈顺序了
    88                              <2> ; 使用方法：
    89                              <2> ;   call    要调用的函数, 返回值存储地址，{参数1, 参数2, 参数3}
    90                              <2> ; ---------------------------------------
    91                              <2> %macro smallcall 3
    92                              <2> callpush %3
    93                              <2> call %1
    94                              <2> callbackpop %2
    95                              <2> %endmacro
    96                              <2> 
    97                              <2> ; ---------------------------------------
    98                              <2> ; 宏说明：
    99                              <2> ;   将指定的段的段地址保存到指定寄存器中
   100                              <2> ; 使用方法：
   101                              <2> ;    myseg    段寄存器, 段名称
   102                              <2> ; ---------------------------------------
   103                              <2> %macro  myseg 2.nolist         
   104                              <2>     multipush   ax
   105                              <2>     ;
   106                              <2>     mov ax, section.%2.start
   107                              <2>     mov %1,ax
   108                              <2>     ;
   109                              <2>     multipop    ax             
   110                              <2> %endmacro 
   111                              <2> 
   112                              <2> 
   113                              <2> ; ---------------------------------------
   114                              <2> ; 宏说明：
   115                              <2> ;   将指定值复制到指定内存中, 安全函数，不会改变借用的寄存器的值
   116                              <2> ; 使用方法：
   117                              <2> ;    memset    借用的寄存器, 内存地址, 值
   118                              <2> ; ---------------------------------------
   119                              <2> %macro  memset 3.nolist         
   120                              <2>     multipush   %1
   121                              <2>     ;
   122                              <2>     mov %1, %3
   123                              <2>     mov %2,%1
   124                              <2>     ;
   125                              <2>     multipop    %1             
   126                              <2> %endmacro 
   127                              <2> 
   128                              <2> ; ---------------------------------------
   129                              <2> ; 宏说明：
   130                              <2> ;   将指定值复制到指定内存中, 与memset的不同是，不安全函数，会改变借用的寄存器的值
   131                              <2> ; 使用方法：
   132                              <2> ;    memset_byax    借用的寄存器, 内存地址, 值
   133                              <2> ; ---------------------------------------
   134                              <2> %macro  memset_unsafe 3.nolist         
   135                              <2>     ;
   136                              <2>     mov %1, %3
   137                              <2>     mov %2, %1
   138                              <2>     ;          
   139                              <2> %endmacro 
   140                              <2> 
   141                              <2> %endif
     9                              <1> 
    10                              <1> ; ================================================================
    11                              <1> ; 调用宏定义
    12                              <1> ; 所有函数都使用对应的宏定义来调用
    13                              <1> ; ================================================================
    14                              <1> 
    15                              <1>     ; ---------------------------------------
    16                              <1>     ; 宏说明：
    17                              <1>     ;   封装了对磁盘读写的调用，实际使用的是函数disk_io
    18                              <1>     ; 使用方法：
    19                              <1>     ;   disk_io  磁盘起始扇区, 扇区数, 内存地址, 读(42h)/写(43h), 返回值
    20                              <1>     ;   
    21                              <1>     ; ---------------------------------------
    22                              <1> %macro  disk_io 5.nolist
    23                              <1>     push strict word 0      ; 返回值 
    24                              <1>     push strict word %4     ; 读(42h)/写(43h) opertation
    25                              <1>     push strict word %3     ; 内存地址 memaddr
    26                              <1>     push strict word %2     ; 扇区数 count
    27                              <1>     push strict word %1     ; 磁盘起始扇区 offset     
    28                              <1>     call proc_disk_io
    29                              <1>     mov %5, ax
    30                              <1>     pop ax
    31                              <1>     pop ax
    32                              <1>     pop ax
    33                              <1>     pop ax
    34                              <1>     mov ax, %5
    35                              <1>     pop %5
    36                              <1> %endmacro 
    37                              <1> 
    38                              <1> ; ================================================================
    39                              <1> ; 调用函数
    40                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
    41                              <1> ; ================================================================
    42                              <1> 
    43                              <1> ; 定义自己的段
    44                              <1> section lib_disk_section
    45                              <1> 
    46                              <1> struc disk_io_param_context
    47 00000000 <res 00000001>      <1>     .PacketSize  resb    1;  数据包尺寸(16字节)
    48 00000001 <res 00000001>      <1>     .Reserved    resb    1;  ==0
    49 00000002 <res 00000002>      <1>     .BlockCount  resw    1; // 要传输的数据块个数(以扇区为单位)
    50 00000004 <res 00000002>      <1>     .BufferAddr1 resw    1; // 传输缓冲地址 segment
    51 00000006 <res 00000002>      <1>     .BufferAddr2 resw    1; // 传输缓冲地址 offset 
    52 00000008 <res 00000002>      <1>     .BlockNum1  resw     1; // 磁盘起始绝对块地址
    53 0000000A <res 00000002>      <1>     .BlockNum2  resw     1; // 磁盘起始绝对块地址
    54 0000000C <res 00000002>      <1>     .BlockNum3  resw     1; // 磁盘起始绝对块地址
    55 0000000E <res 00000002>      <1>     .BlockNum4  resw     1; // 磁盘起始绝对块地址 
    56                              <1> endstruc
    57                              <1> 
    58                              <1>     ; ---------------------------------------
    59                              <1>     ; 函数说明：
    60                              <1>     ;   磁盘读写的封装函数
    61                              <1>     ; 使用方法：
    62                              <1>     ;   使用宏定义, disk_io 
    63                              <1>     ; ---------------------------------------
    64                              <1> proc_disk_io:
    65                              <1>     ; 函数的一些相关定义
    66                              <1>     %push disk_io_context         ; 上下文压栈            
    67                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
    68                              <1>     %assign %$localsize 16 
    69                              <1>     %arg offset:word, count:word, memaddr:word, opertation:word, rv:word    ; 定义参数
    70                              <1>     %local a1:qword, param:qword
    71                              <1> 
    72                              <1>     ; 函数体正式开始
    73 00000000 C8100000            <1>     enter       16,    0   ; 确保堆栈平衡，以及开辟空间   
    74 00000004 5051531E56          <1>     multipush   ax,cx,bx,ds,si            ; 保存原始寄存器值 
    75                              <1>     
    76 00000009 B0108846F0          <1>     memset_unsafe al, [param + disk_io_param_context.PacketSize], 16            ; 给PacketSize 赋值16
    77 0000000E B0008846F1          <1>     memset_unsafe al, [param + disk_io_param_context.Reserved], 0               ; 给Reserved 设置为0
    78 00000013 8B46068946F2        <1>     memset_unsafe ax, [param + disk_io_param_context.BlockCount], [count]       ; 设置去取的扇区数量
    79 00000019 8B46088946F4        <1>     memset_unsafe ax, [param + disk_io_param_context.BufferAddr1], [memaddr]    ; 内存段地址
    80 0000001F B800008946F6        <1>     memset_unsafe ax, [param + disk_io_param_context.BufferAddr2], 0            ; 内存偏移地址
    81 00000025 8B46048946F8        <1>     memset_unsafe ax, [param + disk_io_param_context.BlockNum1], [offset]       ; 磁盘地址
    82 0000002B B800008946FA        <1>     memset_unsafe ax, [param + disk_io_param_context.BlockNum2], 0              ; 磁盘地址
    83 00000031 B800008946FC        <1>     memset_unsafe ax, [param + disk_io_param_context.BlockNum3], 0              ; 磁盘地址
    84 00000037 B800008946FE        <1>     memset_unsafe ax, [param + disk_io_param_context.BlockNum4], 0             ; 磁盘地址
    85                              <1> 
    86                              <1>     ; ds:si是磁盘本参数的地址
    87 0000003D B80000              <1>     mov ax, 0
    88 00000040 8ED8                <1>     mov ds, ax
    89 00000042 89E8                <1>     mov ax, bp
    90 00000044 83E810              <1>     sub ax, 16
    91 00000047 89C6                <1>     mov si, ax
    92 00000049 8A660A              <1>     mov ah, [opertation]
    93 0000004C B280                <1>     mov dl, 80h
    94 0000004E CD13                <1>     int 13h
    95 00000050 88E0                <1>     mov al,ah
    96 00000052 B400                <1>     mov ah,0
    97 00000054 89460C              <1>     mov [rv], ax
    98                              <1> 
    99 00000057 5E1F5B5958          <1>     multipop   ax,cx,bx,ds,si               ; 恢复原始寄存器值
   100 0000005C C9                  <1>     leave                                   ; 恢复堆栈
   101                              <1> 
   102 0000005D C3                  <1>     ret
   103                              <1>     %pop                        ; 上下文出栈
   104                              <1> 
   105                              <1> 
   106                              <1> 
   107                              <1> 
   108                              <1> 
   109                              <1> 
   110                              <1> 
   111                              <1> %endif
   112                              <1> 
    13                                  %include "KEYBOARD.ASM"
     1                              <1> ; ================================================================
     2                              <1> ; 键盘相关功能的宏定义,使用NASM的16位汇编完成
     3                              <1> ; 完成功能：
     4                              <1> ;     完成接收键盘输入的宏定义
     5                              <1> ; ================================================================
     6                              <1> 
     7                              <1> %ifndef lib_keyboard
     8                              <1> %define lib_keyboard
     9                              <1> %include "PRINT.ASM"
     1                              <2> ; ================================================================
     2                              <2> ; 这是关于打印信息的相关宏定义,使用NASM的16位汇编完成
     3                              <2> ; 完成功能：
     4                              <2> ;     字符串打赢的宏定义
     5                              <2> ; ================================================================
     6                              <2> 
     7                              <2> %ifndef lib_print
     8                              <2> %define lib_print
     9                              <2> 
    10                              <2> %include "COMMON.ASM"
    11                              <2> 
    12                              <2> ; ================================================================
    13                              <2> ; 调用宏定义
    14                              <2> ; 所有函数都使用对应的宏定义来调用
    15                              <2> ; ================================================================
    16                              <2> %macro printf_init 0
    17                              <2>     call proc_printf_init
    18                              <2> %endmacro
    19                              <2> 
    20                              <2> 
    21                              <2> ; ---------------------------------------
    22                              <2> ; 宏说明：
    23                              <2> ;   清楚屏幕内容
    24                              <2> ; 使用方法：
    25                              <2> ;   printfreturn    
    26                              <2> ; ---------------------------------------
    27                              <2> %macro printfclear 0
    28                              <2>     call proc_printf_clear
    29                              <2> %endmacro
    30                              <2> 
    31                              <2> ; ---------------------------------------
    32                              <2> ; 宏说明：
    33                              <2> ;   回到行的开头
    34                              <2> ; 使用方法：
    35                              <2> ;   printfreturn    
    36                              <2> ; ---------------------------------------
    37                              <2> %macro printfreturn 0
    38                              <2>     call proc_printfreturn
    39                              <2> %endmacro
    40                              <2> 
    41                              <2> ; ---------------------------------------
    42                              <2> ; 宏说明：
    43                              <2> ;   换到下一行
    44                              <2> ; 使用方法：
    45                              <2> ;   printfaddlen    长度
    46                              <2> ; ---------------------------------------
    47                              <2> %macro printfenter 0
    48                              <2>     call proc_printfenter
    49                              <2> %endmacro
    50                              <2> 
    51                              <2> 
    52                              <2> ; ---------------------------------------
    53                              <2> ; 宏说明：
    54                              <2> ;   回车换行
    55                              <2> ; 使用方法：
    56                              <2> ;   printfendl    长度
    57                              <2> ; ---------------------------------------
    58                              <2> %macro printfendl 0
    59                              <2>     call proc_printfendl
    60                              <2> %endmacro
    61                              <2> 
    62                              <2> 
    63                              <2> ; ---------------------------------------
    64                              <2> ; 宏说明：
    65                              <2> ;   增加每一行的打印起始点坐标
    66                              <2> ; 使用方法：
    67                              <2> ;   printfaddlen    长度
    68                              <2> ; ---------------------------------------
    69                              <2> %macro printfaddlen 1
    70                              <2>     multipush ax
    71                              <2>     push %1
    72                              <2>     call proc_printfaddlen
    73                              <2>     pop ax
    74                              <2>     multipop ax
    75                              <2> %endmacro
    76                              <2> 
    77                              <2> ; ---------------------------------------
    78                              <2> ; 宏说明：
    79                              <2> ;   打印一段字符串
    80                              <2> ; 使用方法：
    81                              <2> ;   printf    字符串起始地址,字符串的长度
    82                              <2> ; ---------------------------------------
    83                              <2> %macro printf 2
    84                              <2>     multipush ax
    85                              <2>     push %2
    86                              <2>     push %1
    87                              <2>     call proc_printf
    88                              <2>     pop ax
    89                              <2>     pop ax
    90                              <2>     multipop ax
    91                              <2> %endmacro
    92                              <2> 
    93                              <2> ; ---------------------------------------
    94                              <2> ; 宏说明：
    95                              <2> ;   打印一段字符串
    96                              <2> ; 使用方法：
    97                              <2> ;   printf    字符串起始地址,字符串的长度, 颜色
    98                              <2> ; 其他说明：
    99                              <2> ;       颜色
   100                              <2> ;        0	黑色		8	灰色	
   101                              <2> ;        1	蓝色		9	亮蓝色	 
   102                              <2> ;        2	绿色		A	亮绿色	
   103                              <2> ;        3	青色		B	亮青色	
   104                              <2> ;        4	红色		C	亮红色	
   105                              <2> ;        5	紫红色		D	亮紫红色	
   106                              <2> ;        6	棕色		E	黄色	
   107                              <2> ;        7	银色	 	F	白色	
   108                              <2> ; ---------------------------------------
   109                              <2> %macro printf_color 3
   110                              <2>     multipush ax
   111                              <2>     push %3
   112                              <2>     push %2
   113                              <2>     push %1
   114                              <2>     call proc_printf_color
   115                              <2>     pop ax
   116                              <2>     pop ax
   117                              <2>     pop ax
   118                              <2>     multipop ax
   119                              <2> %endmacro
   120                              <2> 
   121                              <2> 
   122                              <2> ; ================================================================
   123                              <2> ; 调用函数
   124                              <2> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
   125                              <2> ; ================================================================
   126                              <2> 
   127                              <2> section .bss
   128                              <2>     lib_string_hang resb 1              ; 最多25行
   129                              <2>     lib_string_lie  resb 1              ; 一行最多80个字符
   130                              <2> section lib_print_section
   131                              <2> 
   132                              <2> ; ---------------------------------------
   133                              <2> ; 函数说明：
   134                              <2> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   135                              <2> ; 使用方法：
   136                              <2> ;   printfaddlen    长度
   137                              <2> ; ---------------------------------------
   138                              <2> proc_printf_init:
   139                              <2>     enter 0, 0
   140                              <2>     multipush   ax
   141                              <2>     mov ax, 0
   142                              <2>     mov [lib_string_hang], al
   143                              <2>     mov [lib_string_lie], al
   144                              <2>     multipop   ax
   145                              <2>     leave
   146                              <2>     ret
   147                              <2> 
   148                              <2> ; ---------------------------------------
   149                              <2> ; 函数说明：
   150                              <2> ;   重新设定光标位置
   151                              <2> ; 使用方法：
   152                              <2> ;   printfaddlen    长度
   153                              <2> ; ---------------------------------------
   154                              <2> proc_printf_pos:
   155                              <2>     enter 0, 0
   156                              <2>     multipush ax,bx,dx
   157                              <2>     mov ax,0
   158                              <2>     mov ah, 02h
   159                              <2>     mov bh,0
   160                              <2>     mov dh, [lib_string_hang]
   161                              <2>     mov dl, [lib_string_lie]
   162                              <2>     int 10h
   163                              <2>     multipop ax,bx,dx
   164                              <2>     leave
   165                              <2>     ret
   166                              <2> 
   167                              <2> ; ---------------------------------------
   168                              <2> ; 函数说明：
   169                              <2> ;   回到行的开头
   170                              <2> ; 使用方法：
   171                              <2> ;   printfreturn    
   172                              <2> ; ---------------------------------------
   173                              <2> proc_printfreturn:
   174                              <2>     enter 0, 0
   175                              <2>     multipush   ax
   176                              <2>     mov al, 0 
   177                              <2>     mov [lib_string_lie],  al
   178                              <2>     call proc_printf_pos
   179                              <2>     multipop   ax   
   180                              <2>     leave
   181                              <2>     ret
   182                              <2> ; ---------------------------------------
   183                              <2> ; 函数说明：
   184                              <2> ;   换到下一行
   185                              <2> ; 使用方法：
   186                              <2> ;   printfaddlen    长度
   187                              <2> ; ---------------------------------------
   188                              <2> proc_printfenter:
   189                              <2>     enter 0, 0
   190                              <2>     multipush   ax
   191                              <2>     mov al, [lib_string_hang] 
   192                              <2>     cmp al, 24                         ; 如果 lib_string_hang = 24，那么不能再增加了
   193                              <2>     jz  .donothing
   194                              <2>     add al, 1                          ; 否则 AL+1
   195                              <2>     mov [lib_string_hang],  al
   196                              <2>     call proc_printf_pos
   197                              <2> .donothing:
   198                              <2>     multipop   ax   
   199                              <2>     leave
   200                              <2>     ret
   201                              <2> 
   202                              <2> ; ---------------------------------------
   203                              <2> ; 函数说明：
   204                              <2> ;   回车换行
   205                              <2> ; 使用方法：
   206                              <2> ;   printfendl    长度
   207                              <2> ; ---------------------------------------
   208                              <2> proc_printfendl:
   209                              <2>     enter 0, 0
   210                              <2>     printfenter
   211                              <2>     printfreturn
   212                              <2>     leave
   213                              <2>     ret
   214                              <2> 
   215                              <2> ; ---------------------------------------
   216                              <2> ; 函数说明：
   217                              <2> ;   增加每一行的打印起始点坐标
   218                              <2> ; 使用方法：
   219                              <2> ;   printfaddlen    长度
   220                              <2> ; ---------------------------------------
   221                              <2> proc_printfaddlen:
   222                              <2>     %push disk_io_context         ; 上下文压栈            
   223                              <2>     %stacksize large              ; 设置使用bp寄存器来寻址        
   224                              <2>     %arg length:word ; 定义参数
   225                              <2> 
   226                              <2>     enter 0, 0
   227                              <2>     multipush   ax
   228                              <2>     mov ax, 0
   229                              <2>     mov al,[lib_string_lie]
   230                              <2>     add ax, [length]
   231                              <2> .again:
   232                              <2>     cmp ax, 80
   233                              <2>     ja .dayu
   234                              <2>     jb .xiaoyu
   235                              <2>     jmp .dengyu
   236                              <2> .xiaoyu:   ; 小于就结束了
   237                              <2>     mov [lib_string_lie], al 
   238                              <2>     jmp .end           
   239                              <2> .dayu:     ; 大于，还需要循环
   240                              <2>     sub ax, 80
   241                              <2>     printfendl
   242                              <2>     jmp .again
   243                              <2> .dengyu:   ; 等于也结束了
   244                              <2>     printfendl
   245                              <2> .end:
   246                              <2>     multipop   ax
   247                              <2>     leave
   248                              <2>     ret
   249                              <2> 
   250                              <2>     %pop
   251                              <2> 
   252                              <2> ; ---------------------------------------
   253                              <2> ; 函数说明：
   254                              <2> ;   初始化打印信息，主要是初始化行列的初始值，和屏幕模式
   255                              <2> ; 使用方法：
   256                              <2> ;   printfaddlen    长度
   257                              <2> ; ---------------------------------------
   258                              <2> proc_printf_clear:
   259                              <2>     enter 0, 0
   260                              <2>     multipush   ax,cx,dx,bx
   261                              <2> 
   262                              <2>     mov ah,0x06
   263                              <2>     mov al,0   ;清窗口
   264                              <2>     mov cx,0   ;左上角的行号
   265                              <2>     mov dh,25  ;右下角的行号
   266                              <2>     mov dl,80  ;右下角的行号
   267                              <2>     mov bh,0x0f;属性为黑底白字
   268                              <2>     int 0x10
   269                              <2> 
   270                              <2>     mov al, 0 
   271                              <2>     mov [lib_string_lie],  al
   272                              <2>     mov [lib_string_hang],  al
   273                              <2>     call proc_printf_pos
   274                              <2> 
   275                              <2>     multipop   ax,cx,dx,bx
   276                              <2>     leave
   277                              <2>     ret
   278                              <2> 
   279                              <2> ; ---------------------------------------
   280                              <2> ; 函数说明：
   281                              <2> ;   打印一段字符串
   282                              <2> ; 使用方法：
   283                              <2> ;   printf    字符串起始地址,字符串的长度
   284                              <2> ; ---------------------------------------
   285                              <2> proc_printf:
   286                              <2>     %push disk_io_context         ; 上下文压栈            
   287                              <2>     %stacksize large              ; 设置使用bp寄存器来寻址        
   288                              <2>     %arg offset:word, length:word ; 定义参数
   289                              <2> 
   290                              <2>     enter 0, 0
   291                              <2>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   292                              <2> 
   293                              <2>     mov cx, [length]                ; CX = 串长度
   294                              <2>     mov bx, 000fh                   ; 页号为0(BH = 0) 黑底白字(BL = 0Fh,高亮)
   295                              <2>     mov dl, [lib_string_lie]        ; 列
   296                              <2>     mov dh, [lib_string_hang]       ; 行
   297                              <2> 
   298                              <2>     mov ax, [offset]
   299                              <2>     push bp
   300                              <2>     mov bp, ax                      ; ES:BP = 串地址
   301                              <2>     mov ax, 01301h                  ; AH = 13, AL = 01h
   302                              <2>     int 10h ; 10h 号中断
   303                              <2>     pop bp
   304                              <2> 
   305                              <2>     mov cx, [length]
   306                              <2>     printfaddlen    cx
   307                              <2> 
   308                              <2>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   309                              <2>     leave
   310                              <2>     ret
   311                              <2> 
   312                              <2>     %pop
   313                              <2> 
   314                              <2> ; ---------------------------------------
   315                              <2> ; 函数说明：
   316                              <2> ;   打印一段字符串
   317                              <2> ; 使用方法：
   318                              <2> ;   printf    字符串起始地址,字符串的长度, 颜色
   319                              <2> ; 其他说明：
   320                              <2> ;       颜色
   321                              <2> ;        0	黑色		8	灰色	
   322                              <2> ;        1	蓝色		9	亮蓝色	 
   323                              <2> ;        2	绿色		A	亮绿色	
   324                              <2> ;        3	青色		B	亮青色	
   325                              <2> ;        4	红色		C	亮红色	
   326                              <2> ;        5	紫红色		D	亮紫红色	
   327                              <2> ;        6	棕色		E	黄色	
   328                              <2> ;        7	银色	 	F	白色	
   329                              <2> ; ---------------------------------------
   330                              <2> proc_printf_color:
   331                              <2>     %push disk_io_context         ; 上下文压栈            
   332                              <2>     %stacksize large              ; 设置使用bp寄存器来寻址        
   333                              <2>     %arg offset:word, length:word, color:word       ; 定义参数
   334                              <2> 
   335                              <2>     enter 0, 0
   336                              <2>     multipush   ax,bx,cx,dx,bp      ; 将这段宏用到的寄存器压栈，保存内容
   337                              <2>     mov cx, [length]                ; CX = 串长度
   338                              <2> 
   339                              <2>     mov bx, [color]                 ; 前景色和背景色
   340                              <2>     mov bh, 0h                      ; 页号为0(BH = 0) 
   341                              <2>     mov dl, [lib_string_lie]        ; 列
   342                              <2>     mov dh, [lib_string_hang]       ; 行
   343                              <2> 
   344                              <2>     mov ax, [offset]
   345                              <2>     push bp
   346                              <2>     mov bp, ax                      ; ES:BP = 串地址
   347                              <2>     mov ax, 01301h                  ; AH = 13, AL = 01h
   348                              <2>     int 10h ; 10h 号中断
   349                              <2>     pop bp
   350                              <2>     
   351                              <2>     mov cx, [length]
   352                              <2>     printfaddlen    cx
   353                              <2> 
   354                              <2>     multipop   ax,bx,cx,dx,bp       ; 恢复之前保存的内容
   355                              <2>     leave
   356                              <2>     ret
   357                              <2> 
   358                              <2>     %pop
   359                              <2> %endif
    10                              <1> %include "COMMON.ASM"
     1                              <2> ; ================================================================
     2                              <2> ; 通用功能的相关宏定义,使用NASM的16位汇编完成
     3                              <2> ; 完成功能：
     4                              <2> ;     通用功能的
     5                              <2> ; ================================================================
     6                              <2> 
     7                              <2> %ifndef lib_common
     8                              <2> %define lib_common
     9                              <2> 
    10                              <2> ; ---------------------------------------
    11                              <2> ; 宏说明：
    12                              <2> ;   初始化段寄存器
    13                              <2> ; 使用方法：
    14                              <2> ;   intseg  DS,ES
    15                              <2> ; ---------------------------------------
    16                              <2> %macro intseg 2
    17                              <2>     push ax
    18                              <2>     mov ax, %1           
    19                              <2>     mov ds, ax   
    20                              <2>     mov ax, %2           
    21                              <2>     mov es, ax
    22                              <2>     pop ax
    23                              <2> %endmacro 
    24                              <2> 
    25                              <2> ; ---------------------------------------
    26                              <2> ; 宏说明：
    27                              <2> ;   将指定的一些列寄存器压栈
    28                              <2> ; 使用方法：
    29                              <2> ;   multipush    ax,bx,cs,ds,.....
    30                              <2> ; ---------------------------------------
    31                              <2> %macro  multipush 1-*.nolist
    32                              <2> %rep  %0                
    33                              <2>     push    %1          
    34                              <2>     %rotate 1          
    35                              <2> %endrep              
    36                              <2> %endmacro 
    37                              <2> 
    38                              <2> ; ---------------------------------------
    39                              <2> ; 宏说明：
    40                              <2> ;   将指定的一些列寄存器出栈
    41                              <2> ; 使用方法：
    42                              <2> ;   multipop    ax,bx,cs,ds,.....
    43                              <2> ; 其它说明：
    44                              <2> ;   寄存器顺序与使用 multipush 的时候需保持一致
    45                              <2> ; ---------------------------------------
    46                              <2> %macro  multipop 1-*.nolist
    47                              <2> %rep %0          
    48                              <2>     %rotate -1               
    49                              <2>     pop     %1          
    50                              <2> %endrep               
    51                              <2> %endmacro 
    52                              <2> 
    53                              <2> ; ---------------------------------------
    54                              <2> ; 宏说明：
    55                              <2> ;   简化调用时候的传参，此宏定义必须 与 callbackpop 搭配使用
    56                              <2> ; 使用方法：
    57                              <2> ;   call    参数1, 参数2，...
    58                              <2> ; ---------------------------------------
    59                              <2> %macro  callpush 1-*;.nolist
    60                              <2> %push   callcontext
    61                              <2> %assign %$localsize %0
    62                              <2> push 0
    63                              <2> %rep %0          
    64                              <2>     %rotate -1
    65                              <2>     push    %1          
    66                              <2> %endrep       
    67                              <2> %endmacro 
    68                              <2> 
    69                              <2> ; ---------------------------------------
    70                              <2> ; 宏说明：
    71                              <2> ;   简化调用时候的传参，此宏定义必须 与 callpush 搭配使用
    72                              <2> ; 使用方法：
    73                              <2> ;   call    返回值
    74                              <2> ; ---------------------------------------
    75                              <2> %macro  callbackpop 1
    76                              <2> mov %1, ax
    77                              <2> %rep %$localsize          
    78                              <2>     pop ax
    79                              <2> %endrep
    80                              <2> mov ax,%1
    81                              <2> pop %1
    82                              <2> %pop
    83                              <2> %endmacro 
    84                              <2> 
    85                              <2> ; ---------------------------------------
    86                              <2> ; 宏说明：
    87                              <2> ;   封装了 callpush 和  callbackpop 的调用，之后再也不用管参数的压栈顺序了
    88                              <2> ; 使用方法：
    89                              <2> ;   call    要调用的函数, 返回值存储地址，{参数1, 参数2, 参数3}
    90                              <2> ; ---------------------------------------
    91                              <2> %macro smallcall 3
    92                              <2> callpush %3
    93                              <2> call %1
    94                              <2> callbackpop %2
    95                              <2> %endmacro
    96                              <2> 
    97                              <2> ; ---------------------------------------
    98                              <2> ; 宏说明：
    99                              <2> ;   将指定的段的段地址保存到指定寄存器中
   100                              <2> ; 使用方法：
   101                              <2> ;    myseg    段寄存器, 段名称
   102                              <2> ; ---------------------------------------
   103                              <2> %macro  myseg 2.nolist         
   104                              <2>     multipush   ax
   105                              <2>     ;
   106                              <2>     mov ax, section.%2.start
   107                              <2>     mov %1,ax
   108                              <2>     ;
   109                              <2>     multipop    ax             
   110                              <2> %endmacro 
   111                              <2> 
   112                              <2> 
   113                              <2> ; ---------------------------------------
   114                              <2> ; 宏说明：
   115                              <2> ;   将指定值复制到指定内存中, 安全函数，不会改变借用的寄存器的值
   116                              <2> ; 使用方法：
   117                              <2> ;    memset    借用的寄存器, 内存地址, 值
   118                              <2> ; ---------------------------------------
   119                              <2> %macro  memset 3.nolist         
   120                              <2>     multipush   %1
   121                              <2>     ;
   122                              <2>     mov %1, %3
   123                              <2>     mov %2,%1
   124                              <2>     ;
   125                              <2>     multipop    %1             
   126                              <2> %endmacro 
   127                              <2> 
   128                              <2> ; ---------------------------------------
   129                              <2> ; 宏说明：
   130                              <2> ;   将指定值复制到指定内存中, 与memset的不同是，不安全函数，会改变借用的寄存器的值
   131                              <2> ; 使用方法：
   132                              <2> ;    memset_byax    借用的寄存器, 内存地址, 值
   133                              <2> ; ---------------------------------------
   134                              <2> %macro  memset_unsafe 3.nolist         
   135                              <2>     ;
   136                              <2>     mov %1, %3
   137                              <2>     mov %2, %1
   138                              <2>     ;          
   139                              <2> %endmacro 
   140                              <2> 
   141                              <2> %endif
    11                              <1> 
    12                              <1> ; ================================================================
    13                              <1> ; 调用宏定义
    14                              <1> ; 所有函数都使用对应的宏定义来调用
    15                              <1> ; ================================================================
    16                              <1> ; ---------------------------------------
    17                              <1> ; 宏说明：
    18                              <1> ;   获取一个字符输入
    19                              <1> ; 使用方法：
    20                              <1> ;    getchar    返回值
    21                              <1> ; ---------------------------------------
    22                              <1> %macro  getchar 1.nolist       
    23                              <1>     ;
    24                              <1>     call proc_keyboard_clear
    25                              <1>     smallcall proc_keyboard_getchar, %1, {0xffff}
    26                              <1>     ;             
    27                              <1> %endmacro 
    28                              <1> 
    29                              <1> ; ---------------------------------------
    30                              <1> ; 宏说明：
    31                              <1> ;   获取一串字符串
    32                              <1> ; 使用方法：
    33                              <1> ;    getno    内存地址, 内存长度, 返回值
    34                              <1> ; ---------------------------------------
    35                              <1> %macro  getline 3.nolist       
    36                              <1>     ;
    37                              <1>     call proc_keyboard_clear
    38                              <1>     smallcall proc_get_line, %3, {0xffff, %1, %2}
    39                              <1>     ;             
    40                              <1> %endmacro 
    41                              <1> 
    42                              <1> ; ---------------------------------------
    43                              <1> ; 宏说明：
    44                              <1> ;   获取一串密码
    45                              <1> ; 使用方法：
    46                              <1> ;    getno    内存地址, 内存长度, 返回值
    47                              <1> ; ---------------------------------------
    48                              <1> %macro  getpassword 3.nolist       
    49                              <1>     ;
    50                              <1>     call proc_keyboard_clear
    51                              <1>     smallcall proc_get_line, %3, {0x0042, %1, %2}
    52                              <1>     ;             
    53                              <1> %endmacro 
    54                              <1> 
    55                              <1> ; ================================================================
    56                              <1> ; 调用函数
    57                              <1> ; 实际完成功能的函数，尽量不要直接使用函数，而是使用对应的宏定义
    58                              <1> ; ================================================================
    59                              <1> section lib_keyboard_section
    60                              <1> ; ---------------------------------------
    61                              <1> ; 函数说明：
    62                              <1> ;   清理键盘缓存
    63                              <1> ; 使用方法：
    64                              <1> ;    call proc_keyboard_clear
    65                              <1> ; ---------------------------------------
    66                              <1> proc_keyboard_clear:
    67                              <1>     ; 函数的一些相关定义
    68                              <1>     %push keyboard_context         ; 上下文压栈            
    69                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
    70                              <1> 
    71                              <1>     ; 函数体正式开始
    72 00000000 C8000000            <1>     enter       0, 0 ; 确保堆栈平衡，以及开辟空间   
    73 00000004 50                  <1>     multipush   ax,         ; 保存原始寄存器值 
    74                              <1> 
    75                              <1> .again:
    76 00000005 B80000              <1>     mov ax,0
    77 00000008 B401                <1>     mov ah, 1
    78 0000000A CD16                <1>     int 16h
    79 0000000C 7406                <1>     jz .end
    80 0000000E B400                <1>     mov ah, 0
    81 00000010 CD16                <1>     int 16h
    82 00000012 EBF1                <1>     jmp .again
    83                              <1> .end:
    84 00000014 58                  <1>     multipop   ax               ; 恢复原始寄存器值
    85 00000015 C9                  <1>     leave                       ; 恢复堆栈
    86                              <1> 
    87 00000016 C3                  <1>     ret
    88                              <1>     %pop                        ; 上下文出栈
    89                              <1> 
    90                              <1> ; ---------------------------------------
    91                              <1> ; 函数说明：
    92                              <1> ;   清理键盘缓存
    93                              <1> ; 使用方法：
    94                              <1> ;    使用 getchar, getline, getpassword, getno宏
    95                              <1> ; ---------------------------------------
    96                              <1> proc_keyboard_getchar:
    97                              <1>     ; 函数的一些相关定义
    98                              <1>     %push keyboard_context         ; 上下文压栈            
    99                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   100                              <1>     %arg mask:word, rv:word    
   101                              <1> 
   102                              <1>     ; 函数体正式开始
   103 00000017 C8000000            <1>     enter       0, 0            ; 确保堆栈平衡，以及开辟空间   
   104 0000001B 5053                <1>     multipush   ax, bx          ; 保存原始寄存器值 
   105                              <1> 
   106                              <1>     ; 获取字符
   107 0000001D B80000              <1>     mov ax, 0
   108 00000020 CD16                <1>     int 16h
   109 00000022 894606              <1>     mov [rv], ax
   110                              <1> 
   111                              <1>     ; 判断显示字符
   112 00000025 8B5E04              <1>     mov bx, [mask]
   113 00000028 83FB00              <1>     cmp bx,0
   114 0000002B 7431                <1>     jz .end
   115 0000002D 83FBFF              <1>     cmp bx, 0xffff
   116 00000030 7402                <1>     jz .printself
   117 00000032 EB19                <1>     jmp .printmask
   118                              <1> 
   119                              <1> .printself:
   120 00000034 BB0000              <1>     mov bx,0
   121 00000037 88C3                <1>     mov bl, al
   122 00000039 895E04              <1>     mov [mask], bx
   123 0000003C 89EB                <1>     mov bx, bp  ; 定位mask变量的位置
   124 0000003E 83C304              <1>     add bx, 4
   125                              <1>     printf bx, 1
   125 00000041 50                  <2>  multipush ax
   125 00000042 6A01                <2>  push %2
   125 00000044 53                  <2>  push %1
   125 00000045 E8(B300)            <2>  call proc_printf
   125 00000048 58                  <2>  pop ax
   125 00000049 58                  <2>  pop ax
   125 0000004A 58                  <2>  multipop ax
   126                              <1> 
   127 0000004B EB11                <1>     jmp .end
   128                              <1> 
   129                              <1> .printmask:
   130 0000004D 89EB                <1>     mov bx, bp  ; 定位mask变量的位置
   131 0000004F 83C304              <1>     add bx, 4   
   132                              <1>     printf bx, 1
   132 00000052 50                  <2>  multipush ax
   132 00000053 6A01                <2>  push %2
   132 00000055 53                  <2>  push %1
   132 00000056 E8(B300)            <2>  call proc_printf
   132 00000059 58                  <2>  pop ax
   132 0000005A 58                  <2>  pop ax
   132 0000005B 58                  <2>  multipop ax
   133                              <1> 
   134 0000005C EB00                <1>     jmp .end
   135                              <1> .end:
   136 0000005E 5B58                <1>     multipop   ax, bx            ; 恢复原始寄存器值
   137 00000060 C9                  <1>     leave                        ; 恢复堆栈
   138                              <1> 
   139 00000061 C3                  <1>     ret
   140                              <1>     %pop                        ; 上下文出栈
   141                              <1> 
   142                              <1> ; ---------------------------------------
   143                              <1> ; 函数说明：
   144                              <1> ;   获取一个字符
   145                              <1> ; 使用方法：
   146                              <1> ;    使用  getline, getpassword 宏
   147                              <1> ; ---------------------------------------
   148                              <1> proc_get_line:
   149                              <1>     ; 函数的一些相关定义
   150                              <1>     %push keyboard_context         ; 上下文压栈            
   151                              <1>     %stacksize large              ; 设置使用bp寄存器来寻址        
   152                              <1>     %arg mask:word, memaddr:word, memlen:word, rv:word  
   153                              <1> 
   154                              <1>     ; 函数体正式开始
   155 00000062 C8000000            <1>     enter       0, 0            ; 确保堆栈平衡，以及开辟空间   
   156 00000066 50535156            <1>     multipush   ax, bx, cx, si          ; 保存原始寄存器值 
   157                              <1> 
   158 0000006A B80000              <1>     mov ax, 0
   159 0000006D 89460A              <1>     mov [rv], ax
   160 00000070 8B4E08              <1>     mov cx, [memlen]
   161 00000073 8B7606              <1>     mov si, [memaddr]
   162 00000076 8B5E04              <1>     mov bx, [mask]
   163                              <1> 
   164                              <1> .again:
   165                              <1> 
   166                              <1>     ; 获取一个字符
   167                              <1>     smallcall proc_keyboard_getchar, ax, {bx}
   167                              <2> callpush %3
   167                              <3> %push callcontext
   167                              <3> %assign %$localsize %0
   167 00000079 6A00                <3> push 0
   167                              <3> %rep %0
   167                              <3>  %rotate -1
   167                              <3>  push %1
   167                              <3> %endrep
   167                              <4>  %rotate -1
   167 0000007B 53                  <4>  push %1
   167 0000007C E898FF              <2> call %1
   167                              <2> callbackpop %2
   167 0000007F 89C0                <3> mov %1, ax
   167                              <3> %rep %$localsize
   167                              <3>  pop ax
   167                              <3> %endrep
   167 00000081 58                  <4>  pop ax
   167 00000082 89C0                <3> mov ax,%1
   167 00000084 58                  <3> pop %1
   167                              <3> %pop
   168 00000085 3C0D                <1>     cmp al, 0x0d                ; 回车则结束
   169 00000087 7410                <1>     jz .end
   170                              <1> 
   171                              <1>     ; 将获取到的内容拷贝至内存中
   172 00000089 8804                <1>     mov [si], al
   173 0000008B 83C601              <1>     add si, 1
   174                              <1> 
   175                              <1>     ; 增长rv的值
   176 0000008E 8B460A              <1>     mov ax, [rv]
   177 00000091 83C001              <1>     add ax, 1
   178 00000094 89460A              <1>     mov [rv], ax
   179                              <1> 
   180 00000097 E2E0                <1>     loop .again     ; 继续
   181                              <1> 
   182                              <1> .end:
   183 00000099 5E595B58            <1>     multipop   ax, bx, cx, si    ; 恢复原始寄存器值
   184 0000009D C9                  <1>     leave                        ; 恢复堆栈
   185                              <1> 
   186 0000009E C3                  <1>     ret
   187                              <1>     %pop                        ; 上下文出栈
   188                              <1> 
   189                              <1> %endif
    14                                  
    15                                  
    16                                  ; ++++++++++++++++++++++++++++++++++++++++
    17                                  ; 全局定义
    18                                  ; ++++++++++++++++++++++++++++++++++++++++
    19                                  org 07f00h                     ; 指示编译器 程序加载的位置
    20                                  
    21                                  ProgramLoadAddr equ 0xA800
    22                                  ProgramItemsize equ 20
    23                                  
    24                                  ; ++++++++++++++++++++++++++++++++++++++++
    25                                  ; 数据结构
    26                                  ; ++++++++++++++++++++++++++++++++++++++++
    27                                  ; menuitem格式
    28                                  struc ProgramItem
    29 00000000 <res 00000010>               .fileanme resb 16
    30 00000010 <res 00000002>               .filesize resb 2
    31 00000012 <res 00000002>               .fileoffset resb 2
    32                                  endstruc
    33                                  
    34                                  ; ++++++++++++++++++++++++++++++++++++++++
    35                                  ; 数据段
    36                                  ; ++++++++++++++++++++++++++++++++++++++++
    37                                  section .data
    38                                       ; 欢迎字符
    39 00000000 57656C636F6D652054-          defstring strWelcome, strWelcomelen, "Welcome To Asm System"
    39 00000009 6F2041736D20537973-
    39 00000012 74656D             
    40 00000015 4C6F61642050726F67-          defstring strLoadFilErr, strLoadFilErrLen, "Load Program List Error"
    40 0000001E 72616D204C69737420-
    40 00000027 4572726F72         
    41 0000002C 50726F6772616D204C-          defstring strFileInfoErr, strFileInfoErrLen, "Program List Invalid"
    41 00000035 69737420496E76616C-
    41 0000003E 6964               
    42 00000040 41534D4653                   defstring strProgramListSign,  strProgramListSignLen, "ASMFS"
    43 00000045 506C65617365205365-          defstring strProgrmWelcome,  strProgrmWelcomeLen, "Please Select Program To Run (1-9)"
    43 0000004E 6C6563742050726F67-
    43 00000057 72616D20546F205275-
    43 00000060 6E2028312D3929     
    44 00000067 496E707574204E6F3A-          defstring strInputTip,  strInputTipLen, "Input No: "
    44 00000070 20                 
    45 00000071 496E70757420457272-          defstring strInputError,  strInputErrorLen, "Input Error"
    45 0000007A 6F72               
    46                                  ; ++++++++++++++++++++++++++++++++++++++++
    47                                  ; 变量段
    48                                  ; ++++++++++++++++++++++++++++++++++++++++
    49                                  section .bss
    50                                  ProgramListSign:
    51 00000002 <res 00000006>               resb 6                                 ; 6字节的标识符
    52                                  ProgramCount:
    53 00000008 <res 00000002>               resb 2                                 ; 2字节表示程序的数量
    54                                  perlist:
    55 0000000A <res 00000002>               resb 2                                 ; 上一个列表缩在扇区， 暂不支持
    56                                  nextlist:
    57 0000000C <res 00000002>               resb 2                                 ; 下一个列表缩在的扇区， 暂不支持
    58                                  ProgramListItem:
    59 0000000E <res 000001F4>               resb 25*ProgramItemsize                 ; 20个文件选项 每个20 字节 20*25 = 500
    60                                                                               ; 所以这里一共是 512 字节就是一个扇区的大小, 可以偷懒不用解析格式了。。。
    61                                  
    62                                  PrintNo:
    63 00000202 <res 00000002>               resb 2
    64                                  
    65                                  ; ++++++++++++++++++++++++++++++++++++++++
    66                                  ; 代码段
    67                                  ; ++++++++++++++++++++++++++++++++++++++++
    68                                  section .text
    69                                       ; 初始化段寄存器
    70                                       intseg 0, 0
    70 00000000 50                  <1>  push ax
    70 00000001 B80000              <1>  mov ax, %1
    70 00000004 8ED8                <1>  mov ds, ax
    70 00000006 B80000              <1>  mov ax, %2
    70 00000009 8EC0                <1>  mov es, ax
    70 0000000B 58                  <1>  pop ax
    71                                  
    72                                       ; 初始化打印宏
    73                                       printf_init
    73 0000000C E8(0000)            <1>  call proc_printf_init
    74                                       ; 打印欢迎信息
    75                                       printf    strWelcome, strWelcomelen
    75 0000000F 50                  <1>  multipush ax
    75 00000010 6A15                <1>  push %2
    75 00000012 68[0000]            <1>  push %1
    75 00000015 E8(B300)            <1>  call proc_printf
    75 00000018 58                  <1>  pop ax
    75 00000019 58                  <1>  pop ax
    75 0000001A 58                  <1>  multipop ax
    76                                       printfendl
    76 0000001B E8(5500)            <1>  call proc_printfendl
    77                                  
    78                                       ; 设置88号中断
    79                                  exitint:
    80                                       ; 88h * 4 = 220h = 544
    81 0000001E B8[5F01]                     mov ax, int88
    82 00000021 A32002                       mov [220h], ax
    83 00000024 B80000                       mov ax, 0
    84 00000027 A32202                       mov [222h], ax
    85                                  
    86                                       ; 加载文件索引内容
    87                                  loadfile:
    88                                       ; 加载索引表
    89 0000002A 68000068420068-              disk_io 40h, 1h, ProgramListSign, 42h, ax         ; 加载 40h(64扇区), 到指定内存
    89 00000031 [0200]680100684000-
    89 00000039 E8(0000)89C0585858-
    89 00000041 5889C058           
    90 00000045 83F800                       cmp ax, 0
    91                                       ; 加载成功, 检查索引
    92 00000048 7411                         je checkmenu
    93                                       ; 否则打印出错信息
    94                                       printf    strLoadFilErr, strLoadFilErrLen
    94 0000004A 50                  <1>  multipush ax
    94 0000004B 6A17                <1>  push %2
    94 0000004D 68[1500]            <1>  push %1
    94 00000050 E8(B300)            <1>  call proc_printf
    94 00000053 58                  <1>  pop ax
    94 00000054 58                  <1>  pop ax
    94 00000055 58                  <1>  multipop ax
    95                                       printfendl
    95 00000056 E8(5500)            <1>  call proc_printfendl
    96                                  
    97 00000059 EBFE                         jmp $     ; 无限循环
    98                                  
    99                                       ; 字符串检查
   100                                  checkmenu:
   101                                       strcmp strProgramListSign, strProgramListSignLen, ProgramListSign, strProgramListSignLen, ax
   101                              <1>  smallcall proc_strcmp, %5, {%1,%2,%3,%4}
   101                              <2> callpush %3
   101                              <3> %push callcontext
   101                              <3> %assign %$localsize %0
   101 0000005B 6A00                <3> push 0
   101                              <3> %rep %0
   101                              <3>  %rotate -1
   101                              <3>  push %1
   101                              <3> %endrep
   101                              <4>  %rotate -1
   101 0000005D 6A05                <4>  push %1
   101                              <4>  %rotate -1
   101 0000005F 68[0200]            <4>  push %1
   101                              <4>  %rotate -1
   101 00000062 6A05                <4>  push %1
   101                              <4>  %rotate -1
   101 00000064 68[4000]            <4>  push %1
   101 00000067 E8(0000)            <2> call %1
   101                              <2> callbackpop %2
   101 0000006A 89C0                <3> mov %1, ax
   101                              <3> %rep %$localsize
   101                              <3>  pop ax
   101                              <3> %endrep
   101 0000006C 58                  <4>  pop ax
   101 0000006D 58                  <4>  pop ax
   101 0000006E 58                  <4>  pop ax
   101 0000006F 58                  <4>  pop ax
   101 00000070 89C0                <3> mov ax,%1
   101 00000072 58                  <3> pop %1
   101                              <3> %pop
   102 00000073 83F800                       cmp ax, 0
   103                                       ; 加载成功, 检查索引
   104 00000076 7411                         je showmenu
   105                                       ; 否则打印出错信息
   106                                       printf    strFileInfoErr, strFileInfoErrLen
   106 00000078 50                  <1>  multipush ax
   106 00000079 6A14                <1>  push %2
   106 0000007B 68[2C00]            <1>  push %1
   106 0000007E E8(B300)            <1>  call proc_printf
   106 00000081 58                  <1>  pop ax
   106 00000082 58                  <1>  pop ax
   106 00000083 58                  <1>  multipop ax
   107                                       printfendl
   107 00000084 E8(5500)            <1>  call proc_printfendl
   108                                  
   109 00000087 EBFE                         jmp $     ; 无限循环
   110                                  
   111                                       ; 显示菜单
   112                                  showmenu:
   113                                       printf strProgrmWelcome, strProgrmWelcomeLen
   113 00000089 50                  <1>  multipush ax
   113 0000008A 6A22                <1>  push %2
   113 0000008C 68[4500]            <1>  push %1
   113 0000008F E8(B300)            <1>  call proc_printf
   113 00000092 58                  <1>  pop ax
   113 00000093 58                  <1>  pop ax
   113 00000094 58                  <1>  multipop ax
   114                                       printfendl
   114 00000095 E8(5500)            <1>  call proc_printfendl
   115                                  
   116                                       ; 初始化标号
   117 00000098 B82E00                       mov ax, '.'
   118 0000009B A3[0302]                     mov [PrintNo+1], ax
   119 0000009E B83000                       mov ax, '0'
   120                                  
   121                                       ; 程序的数量
   122 000000A1 BB[0E00]                     mov bx, ProgramListItem
   123 000000A4 83EB14                       sub bx, ProgramItemsize
   124 000000A7 8B0E[0800]                   mov cx, [ProgramCount]
   125                                  print:
   126                                       intseg 0, 0
   126 000000AB 50                  <1>  push ax
   126 000000AC B80000              <1>  mov ax, %1
   126 000000AF 8ED8                <1>  mov ds, ax
   126 000000B1 B80000              <1>  mov ax, %2
   126 000000B4 8EC0                <1>  mov es, ax
   126 000000B6 58                  <1>  pop ax
   127                                       ; 打印标号先
   128 000000B7 83C001                       add ax, 1
   129 000000BA A3[0202]                     mov [PrintNo], ax
   130                                       printf PrintNo, 2
   130 000000BD 50                  <1>  multipush ax
   130 000000BE 6A02                <1>  push %2
   130 000000C0 68[0202]            <1>  push %1
   130 000000C3 E8(B300)            <1>  call proc_printf
   130 000000C6 58                  <1>  pop ax
   130 000000C7 58                  <1>  pop ax
   130 000000C8 58                  <1>  multipop ax
   131                                  
   132                                       ; 打印文件名
   133 000000C9 83C314                       add bx, ProgramItemsize
   134                                       printf bx, ProgramItem.filesize - ProgramItem
   134 000000CC 50                  <1>  multipush ax
   134 000000CD 6A10                <1>  push %2
   134 000000CF 53                  <1>  push %1
   134 000000D0 E8(B300)            <1>  call proc_printf
   134 000000D3 58                  <1>  pop ax
   134 000000D4 58                  <1>  pop ax
   134 000000D5 58                  <1>  multipop ax
   135                                       printfendl
   135 000000D6 E8(5500)            <1>  call proc_printfendl
   136 000000D9 E2D0                         loop print
   137                                  
   138                                       ; 等待用户输入
   139                                  waitinput:
   140                                       printf strInputTip, strInputTipLen
   140 000000DB 50                  <1>  multipush ax
   140 000000DC 6A0A                <1>  push %2
   140 000000DE 68[6700]            <1>  push %1
   140 000000E1 E8(B300)            <1>  call proc_printf
   140 000000E4 58                  <1>  pop ax
   140 000000E5 58                  <1>  pop ax
   140 000000E6 58                  <1>  multipop ax
   141 000000E7 E8(0000)6A006AFFE8-          getchar ax
   141 000000EF (1700)89C05889C058 
   142                                       printfendl
   142 000000F7 E8(5500)            <1>  call proc_printfendl
   143 000000FA B400                         mov ah, 0
   144                                       ; 判断输入的有效
   145 000000FC 83F831                       cmp ax, 49
   146 000000FF 724C                         jb invalidinput
   147 00000101 83F839                       cmp ax, 57
   148 00000104 7747                         ja invalidinput
   149                                  
   150                                       ; 至此认为有效了, 标号
   151 00000106 83E831                       sub ax, 49
   152 00000109 3B06[0800]                   cmp ax, [ProgramCount]
   153 0000010D 733E                         jae invalidinput
   154                                  
   155 0000010F B314                         mov bl, ProgramItemsize
   156 00000111 F6E3                         mul bl     
   157 00000113 BB[0E00]                     mov bx, ProgramListItem
   158 00000116 01C3                         add bx, ax
   159                                       printf bx, ProgramItem.filesize - ProgramItem
   159 00000118 50                  <1>  multipush ax
   159 00000119 6A10                <1>  push %2
   159 0000011B 53                  <1>  push %1
   159 0000011C E8(B300)            <1>  call proc_printf
   159 0000011F 58                  <1>  pop ax
   159 00000120 58                  <1>  pop ax
   159 00000121 58                  <1>  multipop ax
   160                                       printfendl
   160 00000122 E8(5500)            <1>  call proc_printfendl
   161                                  
   162                                       ; 加载文件
   163 00000125 53                           push bx
   164 00000126 83C312                       add bx, ProgramItem.fileoffset
   165 00000129 8B07                         mov ax, [bx]
   166 0000012B 5B                           pop bx
   167 0000012C 83C310                       add bx, ProgramItem.filesize
   168 0000012F 8B1F                         mov bx, [bx]
   169 00000131 6800006842006800A8-          disk_io ax, bx, ProgramLoadAddr, 42h, ax         ; 加载 程序
   169 0000013A 5350E8(0000)89C058-
   169 00000142 58585889C058       
   170 00000148 E9(00A8)                     jmp ProgramLoadAddr
   171                                  
   172 0000014B EB8E                         jmp waitinput
   173                                  
   174                                  invalidinput:
   175                                       printf strInputError, strInputErrorLen
   175 0000014D 50                  <1>  multipush ax
   175 0000014E 6A0B                <1>  push %2
   175 00000150 68[7100]            <1>  push %1
   175 00000153 E8(B300)            <1>  call proc_printf
   175 00000156 58                  <1>  pop ax
   175 00000157 58                  <1>  pop ax
   175 00000158 58                  <1>  multipop ax
   176                                       printfendl
   176 00000159 E8(5500)            <1>  call proc_printfendl
   177 0000015C E97CFF                       jmp waitinput
   178                                  
   179                                  int88:
   180                                       ; 这个中断是不返回的，所以要把压栈的flg cs ip抹平
   181                                       ; ax 是返回值
   182 0000015F 5B                           pop bx
   183 00000160 5B                           pop bx
   184 00000161 5B                           pop bx
   185                                  
   186 00000162 B80000                       mov ax,0
   187 00000165 8EC0                         mov es, ax
   188 00000167 8ED8                         mov ds, ax
   189                                       printfclear
   189 00000169 E8(8B00)            <1>  call proc_printf_clear
   190 0000016C E91AFF                       jmp showmenu
   191                                  
   192                                  
   193 0000016F EBFE                         jmp $     ; 无限循环
   194                                  
